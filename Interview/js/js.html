<!doctype html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<script defer src="./main.js"></script>
	<link rel="stylesheet" href="./js.css">
</head>

<body style="padding: 10px; border: 1px solid rgb(204, 199, 199); box-shadow: 0 0 10px 10px rgb(204, 199, 199);">
	<main style="margin: 0 auto; max-width: 2400px; width: 100%;">
		<p>
			Содержание
		<ul>
			<li>
				<a href="#data">Данные</a>
			</li>
			<li>
				<a href="#data-types">Какие типы данных есть в JS?</a>
			</li>
			<li>
				<a href="#mutable">Какие типы в JS изменяемые, а какие нет?</a>
			</li>
			<li>
				<a href="#reference">Что значит ссылка на переменную</a>
			</li>
			<li>
				<a href="#nan">Что такое NaN? Как проверить, что переменная - NaN?</a>
			</li>
			<li>
				<a href="#create-var">Что значит создавать переменную через конструктор или через литерал?</a>
			</li>
			<li>
				<a href="#dot-bracket-notation">Когда при обращении к свойству объекта стоит использовать точечную нотацию,
					а когда квадратные скобки?</a>
			</li>
			<li>
				<a href="#non-exist-prop">Что произойдет, если попытаться получить несуществующее в объекте свойство?</a>
			</li>
			<li>
				<a href="#has-own-prop">Что делает hasOwnProperty?</a>
			</li>
			<li>
				<a href="#null-undefined">Когда использовать null, а когда undefined?</a>
			</li>
			<li>
				<a href="#glob-vars">Какие есть способы создания глобальных переменных?</a>
			</li>
			<li>
				<a href="#use-strict">Для чего нужна директива use strict</a>
			</li>
			<li>
				<a href="#expressions">Выражения</a>
			</li>
			<li>
				<a href="#expression-statement">Что такое выражения и инструкции? В чем отличия между ними?</a>
			</li>
			<li>
				<a href="#var-let-const">Чем отличаются var, let, const? Почему использование const может быть
					предпочтительнее?</a>
			</li>
			<li>
				<a href="#ternar">Что такое тернарный оператор?</a>
			</li>
			<li>
				<a href="#for-in">Что делает оператор for..in? Какие имеются особенности при использовании этого оператора с
					массивами?</a>
			</li>
			<li>
				<a href="#check-var">Как безопасно проверить, что переменная существует (была объявлена), и не словить
					ReferenceError?</a>
			</li>
			<li>
				<a href="#arrays">Массивы</a>
			</li>
			<li>
				<a href="#array-create">Способы создания массивов (литерал, конструктор, фабричные методы Array.from() и
					Array.of());</a>
			</li>
			<li>
				<a href="#arr-delete-item">Удаление элемента из массива (какие есть способы и в чем особенности)</a>
			</li>
			<li>
				<a href="#arr-length">Свойство length у массива</a>
			</li>
			<li>
				<a href="#check-arr">Как проверить, что в переменной лежит массив?</a>
			</li>
			<li>
				<a href="#arr-methods">Что делают, как и когда использовать следующие методы</a>
			</li>
			<li>
				<a href="#functions">Функции</a>
			</li>
			<li>
				<a href="#function-invocation">Какие есть 4 шаблона вызова функции, которые задают контекст выполнения этой
					функции?</a>
			</li>
			<li>
				<a href="#Recursion">Что такое рекурсия? Когда удобно её использовать?</a>
			</li>
			<li>
				<a href="#closure">Что такое замыкания, и в каких случаях они могут быть полезны? Как сохранить состояние с
					помощью замыкания, и для чего это состояние может быть использовано?</a>
			</li>
			<li>
				<a href="#bind">Как реализовать функцию bind?</a>
			</li>
			<li>
				<a href="#problem">Решить такую вот проблему: пускай у нас есть массив ссылок, и наша задача — сделать так,
					чтобы при клике на каждую выводился alertом ее порядковый номер</a>
			</li>
			<li>
				<a href="#callback">Что такое callback (функция обратного вызова)? Когда они обычно применяются?</a>
			</li>
			<li>
				<a href="#curry">Что такое каррирование?</a>
			</li>
			<li>
				<a href="#part">Что такое частичное применение?</a>
			</li>
			<li>
				<a href="#memo">Что такое мемоизация?</a>
			</li>
			<li>
				<a href="#prototype">Прототипы</a>
			</li>
			<li>
				<a href="#function-constructor">Что такое функция-конструктор? Как их создавать и как ими пользоваться?</a>
			</li>
			<li>
				<a href="#what-is-prototype">Что такое прототип? Какие возможности имеет/дает?</a>
			</li>
			<li>
				<a href="#obj-methods">Почему методы объекта лучше хранить в прототипе, а не в самом объекте?</a>
			</li>
			<li>
				<a href="#create func-instance">Можно ли создать инстанс функции через конструктор? И если да, то как, а
					если нет, то какой бы интерфейс вы реализовали бы для этой задачи?</a>
			</li>
			<li>
				<a href="#obj-no-inherit">Как создать объект, который ни от чего не наследуется?</a>
			</li>
			<li>
				<a href="#inherit-approaches">Какие 3 (как минимум) способа есть отнаследоваться в JavaScript-е? В чем
					отличия и нюансы?</a>
			</li>
			<li>
				<a href="#call-parent-method">Как в переопределенном методе у наследующего класса вызвать переопределяемый
					метод родительского?</a>
			</li>
			<li>
				<a href="#bind-class-method">Какие есть способы навсегда привязать метод класса к его инстансу (чтобы this
					всегда был текущим экземпляром класса)</a>
			</li>
		</ul>
		</p>
		<h1 id="js">JS</h1>
		<h2 id="data">Данные</h2>
		<h3 id="data-types">Какие типы данных есть в JS?</h3>
		<ul>
			<li>string</li>
			<li>number</li>
			<li>boolean</li>
			<li>null</li>
			<li>undefined</li>
			<li>symbol</li>
			<li>bigint</li>
			<li>object</li>
			<li>array</li>
			<li>function</li>
		</ul>
		<h3 id="mutable">Какие типы в JS изменяемые, а какие нет?</h3>
		<p>Примитивные типы (string, number, boolean, null, undefined, symbol, bigint) неизменяемые. Это такие типы,
			значения которых можно только перезаписать, но нельзя изменить. Этот механизм связан с тем, как значения
			переменных хранятся в памяти. Мы не пойдём слишком глубоко в эту тему, но, грубо говоря, примитивные типы
			ссылаются на одно и то же значение в памяти», а не примитивные — на разные.</p>
		<p>Тип object - изменяемый</p>
		<h3 id="reference">Что значит ссылка на переменную</h3>
		<p>Это способ присваивания значения переменной, который зависит от типа данных этого значения. Если
			некая сущность, которая присваивается переменной, имеет примитивный тип, то в переменную записывается именно
			значение. Если же речь идёт об объекте - то при назначении его
			переменной в неё записывается ссылка на него, адрес, по которому он расположен в памяти.</p>
		<h3 id="nan">Что такое NaN? Как проверить, что переменная - NaN?</h3>
		<p>Значение NaN используется, чтобы сообщить об операции, результатом которой оказалось не число. В JavaScript
			существует пять операций, которые могут вернуть NaN:
		<pre>
			ошибка парсинга числа (например, при попытке превратить строку в число parseInt('привет')).
			результат математической операции не находится в полей действительных чисел (например, взятие корня от -1).
			один из операндов в арифметической операции — NaN (5 + NaN).
			результат арифметической операции не определён для переданных операндов (undefined + undefined).
			арифметическая операция со строкой, кроме сложения ("привет" * 5)
		</pre>
		</p>
		<p>NaN не равен самому себе. Проверить, что в переменной хранится NaN простым сравнением не получится. Для
			проверки на NaN пользуйтесь функцией Number.isNaN, которая возвращает true если переданное значение — NaN.</p>
		<h3 id="create-var">Что значит создавать переменную через конструктор или через литерал?</h3>
		<p>Через конструктор: const a = new Obj(); // Obj - имя класса или функции-конструктора</p>
		<p>Через литерал: const b = {//перечислить свойства и методы}</p>
		<h3 id="dot-bracket-notation">Когда при обращении к свойству объекта стоит использовать точечную нотацию, а когда
			квадратные скобки?</h3>
		<p>Квадратные скобки - когда имя свойства состоит из нескольких слов или для обращения к свойству, имя которого
			может быть результатом выражения. В остальных случаях используем запись через точку</p>
		<h3 id="non-exist-prop">Что произойдет, если попытаться получить несуществующее в объекте свойство?</h3>
		<p>Вернется undefined</p>
		<pre>
			<code>
			let obj = {};
			console.log(obj.prop); // undefined	
			</code>
		</pre>
		<h3 id="has-own-prop">Что делает hasOwnProperty</h3>
		<p>Обычный цикл for..in не делает различия между свойствами объекта и его прототипа. Может быть нужно посмотреть,
			что находится именно в самом объекте, а не в прототипе. Вызов <b>obj.hasOwnProperty(prop)</b> возвращает true,
			если свойство prop принадлежит самому объекту obj, иначе false.</p>

		<h3 id="null-undefined">Когда использовать null, а когда undefined?</h3>
		<p>null - «ничего», «пусто» или «значение неизвестно»</p>
		<p>undefined - «значение не было присвоено». Если переменная объявлена, но ей не присвоено никакого значения, то
			её значением будет undefined</p>
		<p>Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для
			проверок, была ли переменная назначена.</p>

		<h3 id="glob-vars">Какие есть способы создания глобальных переменных?</h3>
		<p>Глобальная переменная - это свойство глобального объекта (window). Переменные и константы, которые объявлены
			вне функций, вне модулей являются глобальными, т.е. находятся в глобальной области видимости</p>
		<p><b>Область видимости</b> — это часть программы, в которой мы можем обратиться к переменной, функции или
			объекту. Этой частью может быть функция, блок или вся программа в целом — то есть, мы всегда находимся как
			минимум в одной области видимости.</p>
		<p>Если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window,
			тогда получить значение переменной можно обратившись к window.[имя-переменной]. Но это должно быть исключением,
			требующим
			веской причины.</p>
		<h3 id="use-strict">Для чего нужна директива use strict</h3>
		<p>"use strict" включает строгий режим выполнения JavaScript. Эта строка должна располагаться в самом начале
			скрипта, иначе строгий режим не будет работать. В строгом режиме интерпретатор будет явно выбрасывать ошибки на
			действия, которые ранее пропускал. Если строгий режим был включён, то отключить его для файла уже нельзя.</p>
		<h2 id="expressions">Выражения</h2>
		<h3 id="expression-statement">Что такое выражения и инструкции? В чем отличия между ними?</h3>
		<p><b>Выражение (expression)</b>— это код, который после выполнения возвращает какое-либо значение. Например, 5 +
			3 вернёт 8, а Math.random() — случайное число.</p>
		<p><b>Инструкция (statement)</b>— это отдельная команда в коде, которая выполняет определённое действие. Например,
			if позволяет создать ветвление в программе, for позволяет повторять одно и то же действие. В JavaScript все
			инструкции можно поделить на несколько категорий:
		<pre>
			управление потоком выполнения (if и else, switch, throw и т.д.)
			итерации (for, while и т.д.)
			объявление значений (var, let, const)
			функции (function, return и т.д.)
			прочие (debugger, import, export)</p>
		</pre>
		<h3 id="var-let-const">Чем отличаются var, let, const? Почему использование const может быть предпочтительнее?
		</h3>
		<p>Объявление переменных при помощи ключевого слова var было в JavaScript с первых версий. Переменные var можно
			объявлять без присвоения им значения, в таком случае они будут равны undefined. Переменные, объявленные через
			var, имеют функциональную область видимости. Они доступны только в пределах текущей функции или глобального
			объекта, если функции нет. К переменным, объявленным при помощи ключевого слова var, можно обращаться до
			момента объявления. В отличие от let и const ошибки это не вызовет. Данное поведение называется hoisting -
			«всплытие»</p>
		<p>Значение в переменной, созданной через let можно изменять. Стартовое значение const изменить нельзя, будь то
			примитивное значение или ссылка на объект. Однако объект, хранящийся в const можно мутировать. Объекты хранятся
			по ссылке и изменение объекта не приводит к изменению ссылки на него. Используя ключевое слово let можно
			объявить переменную без присвоения ей начального значения. В таком случае она будет равна undefined. При помощи
			const нельзя объявлять переменные без значения. К переменным let и const нельзя обращаться до их объявления в
			коде.
		</p>
		<p> В новом коде используйте только let или const. Используйте let в тех случаях, когда значение переменной
			меняется. Во всех остальных используйте const. Проще всего всегда по умолчанию использовать ключевое слово
			const и исправлять объявление переменной на let если появляется нужда изменить её значение далее в коде</p>
		<p>Зачем нужны константы? Константы защищают код от случайной перезаписи важных значений. Применяют константы в
			двух случаях:
		<ul>
			<li>мы хотим объявить переменную, которая хранит фундаментальное значение для программы. Например, количество
				дней в году, минимальную сумму заказа, форматы дат и т.д.</li>
			<li>мы объявляем переменную и устанавливаем ей значение всего один раз</li>
		</ul>
		</p>
		<h3 id="ternar">Что такое тернарный оператор?</h3>
		<p>Тернарный оператор работает с тремя операндами: одним условием и двумя выражениями. Возвращает первое
			выражение, если условие истинно и второе, если условие ложно: (A) ? (B) : (C). Используется как компактная
			замена условного
			оператора if.</p>
		<h3 id="for-in">Что делает оператор for..in? Какие имеются особенности при использовании этого оператора с
			массивами?</h3>
		<p>Позволяет пройти в цикле по перечисляемым свойствам объекта, в том числе по свойствам из прототипа.</p>
		<p>Перечисляемые свойства объекта – это свойства, которые явно помечены такими. Сказать свойству, что оно
			перечисляемое, можно через специальный метод defineProperty. Но для простоты все свойства, которые добавляются
			к объекту, являются перечисляемыми по умолчанию. Встроенные свойства не перечисляется. Например метод indexOf у
			объекта String или метод toString у любого объекта не участвуют в цикле for...in.</p>
		<p>В цикле будут перечислены не только собственные свойства объекта, но и все перечисляемые свойства из прототипа
			объекта и прототипа прототипа и так далее.</p>
		<p>Порядок перечисления: строковые имена свойств перечисляются в порядке их присвоения к объекту, числовые - в
			отсортированном порядке по возрастанию. <b>Несмотря на договорённости о порядке вывода числовых ключей, не
				нужно использовать for...in для перебора массива. В будущем правила могут измениться. Для перебора у массива
				есть собственные методы: forEach, map и другие. В этих методах порядок перебора гарантирован.</b></p>
		<h3 id="check-var">Как безопасно проверить, что переменная существует (была объявлена), и не словить
			ReferenceError?</h3>


		<pre>
	<code>
		===============================================================
		
		try {
			if (typeof a === 'undefined') {
				console.log('Не определена');
			} else console.log(a);
		} catch (e) { console.log('Определена после проверки'); }
		//Не определена

		===============================================================
		
		let b;
		try {
			if (typeof b === 'undefined') {
				console.log('Не определена');
			} else console.log(b);
		} catch (e) { console.log('Определена после проверки'); }
		//Не определена

		===============================================================

		try {
			if (typeof c === 'undefined') {
				console.log('Не определена');
			} else console.log(c);
		} catch (e) { console.log('Определена после проверки'); }
		let c;
		//Определена после проверки

		===============================================================

		let d = 10;
		try {
			if (typeof d === 'undefined') {
				console.log('Не определена');
			} else console.log(d);
		} catch (e) { console.log('Определена после проверки'); }
		// 10

		===============================================================
	</code>
</pre>
		<script>
			'use strict'
			let a = 10;
			try {
				if (typeof a === 'undefined') {
					console.log('Не определена');
				} else console.log(a);
			} catch (e) { console.log('Определена после проверки'); }
			//let a;
		</script>
		<h2 id="arrays">Массивы</h2>
		<h3 id="array-create">Способы создания массивов (литерал, конструктор, фабричные методы Array.from() и
			Array.of());</h3>
		<p>Литерал массива — это список из нуля или более выражений, каждое из которых представляет элемент массива,
			заключенный в квадратные скобки ( [] ). Когда вы создаете массив, используя литерал массива, он
			инициализируется с помощью переданных значений, которые будут являться его элементами, длина массива будет
			равна числу переданных аргументов. Синтаксис: let arr = [element0, element1, ..., elementN]</p>
		<p>Конструктор Array(). Синтаксис: const arr = new Array(element0, element1[, ...[, elementN]]); elementN —
			элементы, из которых создаётся массив.
			Или const arr = new Array(arrayLength), arrayLength — длина массива (количество элементов )</p>
		<p>Метод Array.of() создает новый массив из произвольного числа аргументов, независимо от их количества и типа.
			Разница между Array.of() и конструктором Array состоит в обработке единственного аргумента, являющегося целым
			числом:
			Array.of(7) создает массив с одним элементом, тогда как Array(7) создает пустой массив, у которого свойство
			length равно 7 (имеется в виду массив из 7 пустых слотов, а не слотов, содержащих значение undefined)</p>

		<p>Array.of(7); // [7]
			Array(7); // array of 7 empty slots</p>
		<p>Array.of(1, 2, 3); // [1, 2, 3]
			Array(1, 2, 3); // [1, 2, 3]</p>
		<h3 id="arr-delete-item">Удаление элемента из массива (какие есть способы и в чем особенности);</h3>

		<p>1. Метод <b>delete</b> (delete arr[1]). При его использовании длина массива не
			изменится. Удаление методом delete нормально для объектов, но для массивов мы обычно хотим, чтобы оставшиеся
			элементы сдвинулись и заняли освободившееся место. Мы ждём, что массив станет короче.
			Поэтому для этого нужно использовать метод <b>splice</b>.</p>
		<p>2. Метод <b>splice</b>. Синтаксис: <b>arr.splice(index[, deleteCount, elem1, ..., elemN])</b>. Он начинает с
			позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место.
			Возвращает массив из удалённых элементов. Метод splice также может вставлять элементы без удаления, для этого
			достаточно установить deleteCount в 0</p>

		<p></p>

		<h3 id="arr-length">Свойство length у массива</h3>
		<h4>Какое значение будет у свойства length массива a и почему:</h4>
		<pre><code>
		const a = [1, 2, 3];
		a[10] = 4;
	</code></pre>
		<p>Ответ: свойство length будет равно 11, потому что между последним элементом (3) и новым (4) появилась «дыра» из
			семи пустых ячеек: [1, 2, 3, empty × 7, 4]</p>
		<h4>Что будет, если переприсвоить новое значение?</h4>
		<p>Свойство length перезаписываемое, вы можете записать в него любое число из диапазона возможных значений. Это
			изменит количество ячеек массива. Если уменьшить значение свойства length, то из конца массива будут отброшены
			элементы, которые не входят в новый размер массива. Если увеличить значение свойства length, то в конец массива
			добавятся пустые ячейки массива. Значение в них не будет установлено и они будут игнорироваться при обходе
			массива. Не записывайте вручную значения в length. Хотя это и возможно, на практике такой код плохо читается.
			Он может неприятно удивить других разработчиков из-за того, что изменяет размер массива. Об этом побочном
			эффекте знают не все.
		</p>
		<h4>Влияет ли на length удаление элемента посередине массива? Какие способы удаления элементов влияют на длину, а
			какие нет?</h4>
		<p>Зависит от того, как удален элемент. Если удалять методом <b>delete</b> (delete arr[1]), то длина массива не
			изменится. Удаление методом delete нормально для объектов, но для массивов мы обычно хотим, чтобы оставшиеся
			элементы сдвинулись и заняли освободившееся место. Мы ждём, что массив станет короче.
			Поэтому для этого нужно использовать метод <b>splice</b>. Его синтаксис:</p>
		<p>arr.splice(index[, deleteCount, elem1, ..., elemN])</p>
		<p>Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место.
			Возвращает массив из удалённых элементов. Метод splice также может вставлять элементы без удаления, для этого
			достаточно установить deleteCount в 0</p>


		<h3 id="check-arr">Как проверить, что в переменной лежит массив?</h3>
		<p>Метод Array.isArray() проверяет, является ли переданный аргумент массивом. Возвращает true, если является, и
			false — если нет.</p>

		<h3 id="arr-methods">Что делают, как и когда использовать следующие методы</h3>

		<h4>reduce</h4>
		<p>Позволяет превратить массив в любое другое значение с помощью переданной функции-колбэка и начального значения.
			Функция-колбэк будет вызвана для каждого элемента массива и всегда должна возвращать результат. Метод reduce
			принимает два параметра: функцию-колбэк и начальное значение для аккумулятора.
		<ul>Сама функция-колбэк может принимать четыре параметра:
			<li>acc — текущее значение аккумулятора</li>
			<li>item — элемент массива в текущей итерации</li>
			<li>index — индекс текущего элемента</li>
			<li>arr — сам массив, который мы перебираем</li>
		</ul>
		</p>

		<h4>sort</h4>
		<p>Cортирует массив, меняя в нём порядок элементов. Он возвращает отсортированный массив, но обычно возвращаемое
			значение игнорируется, так как изменяется сам arr. Принимает коллбэк, описывающий, как должны сортироваться
			значения. Функция должна для пары значений возвращать:</p>
		<pre><code>
		function compare(a, b) {
		if (a > b) return 1; // если первое значение больше второго
		if (a == b) return 0; // если равны
		if (a < b) return -1; // если первое значение меньше второго } 
		</code></pre>
		<p>По умолчанию (если коллбэк не передан) элементы сортируются как строки.</p>



		<p>Все указанные методы принимают коллбэк-функцию,
			которая принимает три параметра: item — элемент массива в текущей итерации; index — индекс текущего элемента;
			arr — сам массив, который мы перебираем.</p>

		<h4>filter</h4>
		<p>Позволяет получить новый массив, отфильтровав элементы с помощью переданной колбэк-функции. Колбэк-функция
			будет вызвана для каждого элемента массива и по результату функции примет решение включать этот элемент в новый
			массив или нет.</p>
		<p>Аналогично методу forEach, методу filter необходимо передать аргументом функцию. Главное отличие — функция
			должна возвращать boolean, т. е. результатом должен быть true или false. Такие функции называют предикатами.
		</p>



		<h4>map</h4>
		<p>Метод map позволяет трансформировать один массив в другой при помощи функций-колбэка. Переданная функция
			будет вызвана для каждого элемента массива по порядку. Из результатов вызова функции будет собран новый массив.
			map возвращает новый массив, при этом исходный массив никак не изменится. При работе с map необходимо
			возвращать
			значение из функции-колбэка. Если не вернуть значение — например, забыв обработать какую-то ветку условия,
			то в итоговом массиве будет undefined</p>

		<h4>forEach</h4>
		<p>Выполняет функцию-коллбэк один раз для каждого элемента массива. Массив, к которому применяется метод, не
			изменяется</p>

		<h4>some</h4>
		<p>Позволяет узнать, есть ли в массиве хотя бы один элемент, удовлетворяющий условию в
			функции-колбэке. Колбэк-функция будет вызвана для каждого элемента массива до тех пор пока не вернётся true,
			либо пока не закончатся элементы массива. Результатом вызова метода Array.some будет boolean-значение true или
			false. Если ни один элемент в массиве не
			удовлетворит условию, то результат будет false.</p>

		<h4>every</h4>
		<p>Позволяет узнать, удовлетворяют ли все элементы в массиве условию в функции-колбэке. Результатом вызова метода
			Array.every будет boolean-значение true или false. Если хотя бы один элемент не будет удовлетворять условию, то
			результат будет false. <b>Проверка пустого массива всегда вернёт true</b></p>
		<h2 id="functions">Функции</h2>
		<h3 id="function-invocation">Какие есть 4 шаблона вызова функции, которые задают контекст выполнения этой функции?
		</h3>
		<p>Вызов функции — Function Invocation. Значение this будет ссылаться на глобальный объект (window) в нестрогом
			режиме. В строгом режиме this равен undefined</p>
		<p>Вызов метода — Method Invocation. Значение this будет ссылаться на объект, которому принадлежит метод</p>
		<p>Вызов конструктора — Constructor Invocation. This в данном случае будет относиться к свежесозданному объекту
		</p>
		<p>Вызов apply и call — Apply And Call Invocation. Позволяет вручную запустить функцию, попутно снабдив ее
			параметрами и обозначив this. Синтаксис: func.call(obj, 1, 2, 3); func.apply(obj, [1, 2, 3]);</p>
		<h4>Как директива use strict влияет на this внутри функции?</h4>
		<p>При включённом строгом режиме this больше не будет по умолчанию ссылаться на глобальный объект. This по
			умолчанию будет равен undefined</p>
		<h3 id="function-many-args">Какой наиболее простой паттерн, позволяющий облегчить читаемость функции, когда у нее
			огромное количество аргументов?</h3>
		<p>Ответ: использовать спред-синтаксис ...</p>
		<p>спред-синтаксис:
		<pre>
				<code>
			function multiplyThreeNumbers(a, b, c) {
			return a * b * c
				}
			const nums = [1, 2, 3, 5, 6]
			console.log(multiplyThreeNumbers(...nums))
			 // 6
				</code>
			</pre>


		</p>
		<h3>Как получить все аргументы функции (включая те, что не объявлены, но все-таки были переданы)?</h3>
		<p>Ответ: использовать остаточные параметры или переменную arguments (устаревший способ)
		<p>Остаточные параметры могут быть обозначены через три точки .... Буквально это значит: «собери оставшиеся
			параметры и положи их в массив».</p>
		<pre><code>
				function sumAll(...args) { // args — имя массива
					let sum = 0;
				 	for (let arg of args) sum += arg;
				 	return sum;
				 }
			</code></pre>
		</p>
		<p>Мы можем положить первые несколько параметров в переменные, а остальные – собрать в массив.
			В примере ниже первые два аргумента функции станут именем и фамилией, а третий и последующие превратятся в
			массив titles:
		<pre><code>
			function showName(firstName, lastName, ...titles) 
			{// some code}
		</code></pre>
		</p>
		<p>Arguments. Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами, к ним
			можно обратиться в теле функции. Недостаток этого подхода: хотя arguments похож на массив, и его тоже можно
			перебирать, это всё же не массив. Он не поддерживает методы массивов</p>

		<h3 id="closure">Что такое замыкания, и в каких случаях они могут быть полезны? Как сохранить состояние с помощью
			замыкания, и
			для чего это состояние может быть использовано?</h3>
		<h3 id="bind">Как реализовать функцию bind?</h3>
		<p>Это метод, который позволяет связывать контекст выполнения с функцией, чтобы «заранее и точно» определить,
			какое именно значение будет у this.
		<pre><code>
			function greet() {
				console.log(`Hello, ${this.name}`)
			 }
			 
			 const user1 = { name: "Alex" }
			 
			 const greetAlex = greet.bind(user1)
			 greetAlex() // Hello, Alex
			 
		</code></pre>
		</p>
		<h3 id="problem">Решить такую вот проблему: пускай у нас есть массив ссылок, и наша задача — сделать так, чтобы
			при клике на
			каждую выводился alertом ее порядковый номер. Первое решение, что приходит в голову, выглядит так:</h3>
		<a class="link" href="">link 1</a>
		<a class="link" href="">link 2</a>
		<a class="link" href="">link 3</a>
		<a class="link" href="">link 4</a>
		<a class="link" href="">link 5</a>

		<pre><code>
				for (var i = 0; i < links.length; i++) {
					links[i].onclick = function() {
						alert(i);
					}
				}
			</code></pre>
		<p>На деле же оказывается, что при клике на любую ссылку выводится одно и то же число — значение links.length.
			Почему так происходит и как эту гадость исправить?</p>
		<p>Ответ: в замыкании обработчика щелчка хранится ссылка на переменную i, а не фактическое значение i .

			Каждый обработчик щелчка будет ссылаться на один и тот же объект, потому что есть только один объект счетчика,
			который содержит i (5), поэтому вы получаете пять при каждом щелчке. Для достижения желаемого поведения
			необходимо var заменить на let</p>
		<script>
			const links = document.querySelectorAll('.link');
			for (var i = 0; i < links.length; i++) {
				links[i].onclick = function () {
					alert(i);
				}
			}
		</script>

		<h3 id="callback">Что такое callback (функция обратного вызова)? Когда они обычно применяются?</h3>
		<p>В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент callback — функция, которая
			будет вызвана по завершению асинхронного действия.</p>
		<h3 id="curry">Что такое каррирование?</h3>

		<h3 id="part">Что такое частичное применение?</h3>
		<h3 id="memo">Что такое мемоизация?</h3>
		<h2 id="prototype">Прототипы</h2>
		<h3 id="function-constructor">Что такое функция-конструктор? Как их создавать и как ими пользоваться?</h3>
		<p>Функции-конструкторы являются обычными функциями, позволяющими создавать однотипные объекты. Есть два
			соглашения:
		<ul>
			<li>Имя функции-конструктора должно начинаться с большой буквы.</li>
			<li>Функция-конструктор должна вызываться при помощи оператора "new".</li>
		</ul>
		Когда функция вызывается как new User(...), происходит следующее:
		<ul>
			<li>Создаётся новый пустой объект, и он присваивается this.</li>
			<li>Выполняется код функции. Обычно он модифицирует this, добавляет туда новые свойства.</li>
			<li>Возвращается значение this.</li>
		</ul>
		</p>
		<h3 id="what-is-prototype">Что такое прототип? Какие возможности имеет/дает?</h3>
		<p>В JavaScript объекты имеют специальное скрытое свойство [[Prototype]] (так оно названо в спецификации), которое
			либо равно null, либо ссылается на другой объект. Этот объект называется «прототип».
		</p>
		<p>Когда мы хотим прочитать свойство или вызвать метод из object, а оно (он) отсутствует, JavaScript автоматически
			берёт его из прототипа. В программировании такой механизм называется «прототипным наследованием». Прототип
			используется только для чтения свойств. Операции записи/удаления работают напрямую с объектом. Т.е. если
			изначально некле свойство (или метод) было в прототипе, а потом его с тем же именем добавили в объект, то
			использоваться будет свойство/ метод самого объекта, в прототипе его уже искать не будем</p>
		<p><b>Неважно, где находится метод: в объекте или его прототипе. При вызове метода this — всегда объект перед
				точкой.</b></p>
		<p><b>Цикл for..in проходит не только по собственным, но и по унаследованным свойствам объекта. Если
				унаследованные свойства нам не нужны, то мы можем отфильтровать их при помощи встроенного метода
				obj.hasOwnProperty(key): он возвращает true, если у obj есть собственное, не унаследованное, свойство с
				именем key. Почти все остальные методы, получающие ключи/значения, такие как Object.keys, Object.values и
				другие – игнорируют унаследованные свойства. Они учитывают только свойства самого объекта, не его
				прототипа.</b></p>

		<h3 id="obj-methods">Почему методы объекта лучше хранить в прототипе, а не в самом объекте?</h3>
		<p>Лучше с точки зрения использования памяти. Например, есть 1000 объектов, у каждого объекта в конструкторе
			есть метод который делает одно и тоже для каждого объекта. Занимает память? Да. Можно в прототип вынести
			этот метод и метод будет всего один для каждого объекта, а к нему будут вести ссылки. С точки зрения
			оптимизации так будет лучше.</p>

		<h3 id="create func-instance">Можно ли создать инстанс функции через конструктор? И если да, то как, а если нет,
			то какой бы интерфейс вы реализовали бы для этой задачи?</h3>
		<p>Создать инстанс функции через конструктор можно. На самом деле каждая JavaScript-функция является объектом
			Function. Это легко проверить, выполнив проверку (function(){}).constructor === Function, которая вернёт true.
		</p>
		<p>Синтаксис: let func = new Function ([arg1, arg2, ...argN], functionBody);</p>
		<p>Функции, объявленные через new Function, имеют [[Environment]], ссылающийся на глобальное лексическое
			окружение, а не на родительское. Поэтому они не могут использовать внешние локальные переменные. </p>

		<h3 id="obj-no-inherit">Как создать объект, который ни от чего не наследуется?</h3>
		<p>Object.create(null) создаёт пустой объект без прототипа ([[Prototype]] будет null):</p>
		<p>Мы можем назвать такой объект «простейшим» или «чистым словарным объектом», потому что он ещё проще, чем
			обычные объекты {...}. Недостаток в том, что у таких объектов не будет встроенных методов объекта, таких как
			toString</p>
		<h3 id="inherit-approaches">Какие 3 (как минимум) способа есть отнаследоваться в JavaScript-е? В чем отличия и
			нюансы?</h3>
		<p> <b>Для существующего объекта:</b></p>
		<ul> Устаревший способ:
			<li>задать значение свойству __proto__: rabbit.__proto__ = animal; <i>__proto__ — не то же самое, что
					[[Prototype]]. Это геттер/сеттер для него.</i>. Встроенный
				геттер/сеттер __proto__ не безопасен, если мы хотим использовать созданные пользователями ключи в объекте.
				Как минимум потому, что пользователь может ввести "__proto__" как ключ, от чего может возникнуть ошибка.
				Если повезёт – последствия будут лёгкими, но, вообще говоря, они непредсказуемы. Так что мы можем
				использовать либо Object.create(null) для создания «простейшего» объекта, либо использовать коллекцию Map.
			</li>
			<li>
				<ul> Современные методы:
					<li>Object.create(proto, [descriptors]) – создаёт пустой объект со свойством [[Prototype]], указанным как
						proto, и необязательными дескрипторами свойств descriptors. Object.create даёт нам лёгкий способ
						создать поверхностную копию объекта со всеми дескрипторами</li>
					<li>Object.getPrototypeOf(obj) – возвращает свойство [[Prototype]] объекта obj.</li>
					<li>Object.setPrototypeOf(obj, proto) – устанавливает свойство [[Prototype]] объекта obj как proto.</li>
				</ul>
			</li>
		</ul>
		<code><pre>
	let parentObj = { //родительский объект
		parentMethod: function () {
		}
	}
	let childObj = {
		childMethod: function () {
		}
	}
	//добавление прототипа ранее созданному объекту
	Object.setPrototypeOf(childObj, parentObj);
	console.log(childObj);
</pre></code>
		<img src="./object.JPG" alt="">
		<p><b>При создании объектов с помощью функции-конструктора:</b></p>
		<pre><code>
			let parentObj = { //родительский объект
				parentMethod: function () {
				}
			}
			function ChildConstructorFunc() {
				this.childMethod = function () {
				}
			}
			ChildConstructorFunc.prototype = parentObj;//наследование от родительского объекта
			console.log(new ChildConstructorFunc());
		</code></pre>
		<img src="./constructor.JPG" alt="">
		<p>Установка ChildConstructorFunc.prototype = parentObj буквально говорит интерпретатору следующее: "При создании
			объекта через new ChildConstructorFunc() запиши ему parentObj в [[Prototype]]".</p>
		<ul>
			<li>Свойство F.prototype (не путать с [[Prototype]]) устанавливает[[Prototype]] для новых объектов при вызове
				new F().</li>
			<li>Значение F.prototype должно быть либо объектом, либо null. Другие значения не будут работать.</li>
			<li><b>Свойство "prototype" является особым, только когда оно назначено функции-конструктору, которая
					вызывается оператором new. </b> </li>
			<li>По умолчанию все функции имеют F.prototype = { constructor: F }, поэтому мы можем получить конструктор
				объекта через свойство "constructor"</li>
		</ul>
		<p><b>При создании объекта с помощью класса:</b></p>
		<p>Для того, чтобы наследовать класс от другого, мы должны использовать ключевое слово "extends" и указать
			название родительского класса перед {..}.</p>
		<pre><code>
				class ParentClass {
					parentMethod() {
					}
				}
				class ChildClass extends ParentClass {
					childMethod() {
					}
				}
				console.log(new ChildClass());
			</code></pre>
		<img src="./class.JPG" alt="">
		<script>
			//наследование от родительского класса
			class ParentClass {
				parentMethod() {
				}
			}
			class ChildClass extends ParentClass {
				childMethod() {
				}
			}
			console.log(new ChildClass());

			//наследование от родительского объекта при создании через функцию-конструктор
			let parentObj = { //родительский объект
				parentMethod: function () {
				}
			}
			function ChildConstructorFunc() {
				this.childMethod = function () {
				}
			}
			ChildConstructorFunc.prototype = parentObj;//наследование от родительского объекта
			console.log(new ChildConstructorFunc());

			//наследование от родительского объекта при создании через литерал
			let childObj = {
				childMethod: function () {
				}
			}
			Object.setPrototypeOf(childObj, parentObj);
			console.log(childObj);
		</script>
		<h3 id="call-parent-method">Как в переопределенном методе у наследующего класса вызвать переопределяемый метод
			родительского? Пример
			псевдокода:</h3>
		<p>
		<pre><code>
			class Person 
				method getFullName()
					return this.name + this.surname

			class Employee extends Person
				method getFullName()
					return super() + this.position
		</code></pre>
		</p>
		<p>Ответ:</p>
		<pre><code>
			class Employee extends Person
				method getFullName()
					return super.getFullName() + this.position
		</code></pre>
		<h3 id="bind-class-method">Какие есть способы навсегда привязать метод класса к его инстансу (чтобы this всегда
			был текущим экземпляром класса)?</h3>
		<a href="https://badcode.ru/kak-priviazat-mietody-klassa-k-ekziempliaru-klassa-s-kontiekstom-this/"
			target="_blank">Ссылка на статью</a>




	</main>

</body>

</html>