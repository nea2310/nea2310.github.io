<!doctype html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<script defer src="./main.js"></script>
	<link rel="stylesheet" href="./js.css">
</head>

<body style="padding: 10px; border: 1px solid rgb(204, 199, 199); box-shadow: 0 0 10px 10px rgb(204, 199, 199);">
	<main style="margin: 0 auto; max-width: 2400px; width: 100%;">
		<p>
			Содержание
		<ul>
			<li>
				<a href="#data">Данные</a>
			</li>
			<li>
				<a href="#data-types">Какие типы данных есть в JS?</a>
			</li>
			<li>
				<a href="#mutable">Какие типы в JS изменяемые, а какие нет?</a>
			</li>
			<li>
				<a href="#reference">Что значит ссылка на переменную</a>
			</li>
			<li>
				<a href="#nan">Что такое NaN? Как проверить, что переменная - NaN?</a>
			</li>
			<li>
				<a href="#create-var">Что значит создавать переменную через конструктор или через литерал?</a>
			</li>
			<li>
				<a href="#dot-bracket-notation">Когда при обращении к свойству объекта стоит использовать точечную нотацию,
					а когда квадратные скобки?</a>
			</li>
			<li>
				<a href="#non-exist-prop">Что произойдет, если попытаться получить несуществующее в объекте свойство?</a>
			</li>
			<li>
				<a href="#has-own-prop">Что делает hasOwnProperty?</a>
			</li>
			<li>
				<a href="#null-undefined">Когда использовать null, а когда undefined?</a>
			</li>
			<li>
				<a href="#glob-vars">Какие есть способы создания глобальных переменных?</a>
			</li>
			<li>
				<a href="#use-strict">Для чего нужна директива use strict</a>
			</li>
			<li>
				<a href="#expressions">Выражения</a>
			</li>
			<li>
				<a href="#expression-statement">Что такое выражения и инструкции? В чем отличия между ними?</a>
			</li>
			<li>
				<a href="#var-let-const">Чем отличаются var, let, const? Почему использование const может быть
					предпочтительнее?</a>
			</li>
			<li>
				<a href="#ternar">Что такое тернарный оператор?</a>
			</li>
			<li>
				<a href="#for-in">Что делает оператор for..in? Какие имеются особенности при использовании этого оператора с
					массивами?</a>
			</li>
			<li>
				<a href="#check-var">Как безопасно проверить, что переменная существует (была объявлена), и не словить
					ReferenceError?</a>
			</li>
			<li>
				<a href="#arrays">Массивы</a>
			</li>
			<li>
				<a href="#array-create">Способы создания массивов (литерал, конструктор, фабричные методы Array.from() и
					Array.of());</a>
			</li>
			<li>
				<a href="#arr-delete-item">Удаление элемента из массива (какие есть способы и в чем особенности)</a>
			</li>
			<li>
				<a href="#arr-length">Свойство length у массива</a>
			</li>
			<li>
				<a href="#check-arr">Как проверить, что в переменной лежит массив?</a>
			</li>
			<li>
				<a href="#arr-methods">Что делают, как и когда использовать следующие методы</a>
			</li>
			<li>
				<a href="#functions">Функции</a>
			</li>
			<li>
				<a href="#function-invocation">Какие есть 4 шаблона вызова функции, которые задают контекст выполнения этой
					функции?</a>
			</li>
			<li>
				<a href="#Recursion">Что такое рекурсия? Когда удобно её использовать?</a>
			</li>
			<li>
				<a href="#closure">Что такое замыкания, и в каких случаях они могут быть полезны? Как сохранить состояние с
					помощью замыкания, и для чего это состояние может быть использовано?</a>
			</li>
			<li>
				<a href="#bind">Как реализовать функцию bind?</a>
			</li>
			<li>
				<a href="#problem">Решить такую вот проблему: пускай у нас есть массив ссылок, и наша задача — сделать так,
					чтобы при клике на каждую выводился alertом ее порядковый номер</a>
			</li>
			<li>
				<a href="#callback">Что такое callback (функция обратного вызова)? Когда они обычно применяются?</a>
			</li>
			<li>
				<a href="#curry">Что такое каррирование?</a>
			</li>
			<li>
				<a href="#part">Что такое частичное применение?</a>
			</li>
			<li>
				<a href="#memo">Что такое мемоизация?</a>
			</li>
			<li>
				<a href="#"></a>
			</li>
			<li>
				<a href="#"></a>
			</li>

		</ul>
		</p>
		<h1 id="js">JS</h1>
		<h2 id="data">Данные</h2>
		<h3 id="data-types">Какие типы данных есть в JS?</h3>
		<ul>
			<li>string</li>
			<li>number</li>
			<li>boolean</li>
			<li>null</li>
			<li>undefined</li>
			<li>symbol</li>
			<li>bigint</li>
			<li>object</li>
			<li>array</li>
			<li>function</li>
		</ul>
		<h3 id="mutable">Какие типы в JS изменяемые, а какие нет?</h3>
		<p>Примитивные типы (string, number, boolean, null, undefined, symbol, bigint) неизменяемые. Это такие типы,
			значения которых можно только перезаписать, но нельзя изменить. Этот механизм связан с тем, как значения
			переменных хранятся в памяти. Мы не пойдём слишком глубоко в эту тему, но, грубо говоря, примитивные типы
			ссылаются на одно и то же значение в памяти», а не примитивные — на разные.</p>
		<p>Тип object - изменяемый</p>
		<h3 id="reference">Что значит ссылка на переменную</h3>
		<p>Это способ присваивания значения переменной, который зависит от типа данных этого значения. Если
			некая сущность, которая присваивается переменной, имеет примитивный тип, то в переменную записывается именно
			значение. Если же речь идёт об объекте - то при назначении его
			переменной в неё записывается ссылка на него, адрес, по которому он расположен в памяти.</p>
		<h3 id="nan">Что такое NaN? Как проверить, что переменная - NaN?</h3>
		<p>Значение NaN используется, чтобы сообщить об операции, результатом которой оказалось не число. В JavaScript
			существует пять операций, которые могут вернуть NaN:
		<pre>
			ошибка парсинга числа (например, при попытке превратить строку в число parseInt('привет')).
			результат математической операции не находится в полей действительных чисел (например, взятие корня от -1).
			один из операндов в арифметической операции — NaN (5 + NaN).
			результат арифметической операции не определён для переданных операндов (undefined + undefined).
			арифметическая операция со строкой, кроме сложения ("привет" * 5)
		</pre>
		</p>
		<p>NaN не равен самому себе. Проверить, что в переменной хранится NaN простым сравнением не получится. Для
			проверки на NaN пользуйтесь функцией Number.isNaN, которая возвращает true если переданное значение — NaN.</p>
		<h3 id="create-var">Что значит создавать переменную через конструктор или через литерал?</h3>
		<p>Через конструктор: const a = new Obj(); // Obj - имя класса или функции-конструктора</p>
		<p>Через литерал: const b = {//перечислить свойства и методы}</p>
		<h3 id="dot-bracket-notation">Когда при обращении к свойству объекта стоит использовать точечную нотацию, а когда
			квадратные скобки?</h3>
		<p>Квадратные скобки - когда имя свойства состоит из нескольких слов или для обращения к свойству, имя которого
			может быть результатом выражения. В остальных случаях используем запись через точку</p>
		<h3 id="non-exist-prop">Что произойдет, если попытаться получить несуществующее в объекте свойство?</h3>
		<p>Вернется undefined</p>
		<pre>
			<code>
			let obj = {};
			console.log(obj.prop); // undefined	
			</code>
		</pre>
		<h3 id="has-own-prop">Что делает hasOwnProperty</h3>
		<p>Обычный цикл for..in не делает различия между свойствами объекта и его прототипа. Может быть нужно посмотреть,
			что находится именно в самом объекте, а не в прототипе. Вызов <b>obj.hasOwnProperty(prop)</b> возвращает true,
			если свойство prop принадлежит самому объекту obj, иначе false.</p>

		<h3 id="null-undefined">Когда использовать null, а когда undefined?</h3>
		<p>null - «ничего», «пусто» или «значение неизвестно»</p>
		<p>undefined - «значение не было присвоено». Если переменная объявлена, но ей не присвоено никакого значения, то
			её значением будет undefined</p>
		<p>Обычно null используется для присвоения переменной «пустого» или «неизвестного» значения, а undefined – для
			проверок, была ли переменная назначена.</p>

		<h3 id="glob-vars">Какие есть способы создания глобальных переменных?</h3>
		<p>Глобальная переменная - это свойство глобального объекта (window). Переменные и константы, которые объявлены
			вне функций, вне модулей являются глобальными, т.е. находятся в глобальной области видимости</p>
		<p><b>Область видимости</b> — это часть программы, в которой мы можем обратиться к переменной, функции или
			объекту. Этой частью может быть функция, блок или вся программа в целом — то есть, мы всегда находимся как
			минимум в одной области видимости.</p>
		<p>Если нам нужно сделать глобальную переменную уровня всей страницы, можно явно присвоить её объекту window,
			тогда получить значение переменной можно обратившись к window.[имя-переменной]. Но это должно быть исключением,
			требующим
			веской причины.</p>
		<h3 id="use-strict">Для чего нужна директива use strict</h3>
		<p>"use strict" включает строгий режим выполнения JavaScript. Эта строка должна располагаться в самом начале
			скрипта, иначе строгий режим не будет работать. В строгом режиме интерпретатор будет явно выбрасывать ошибки на
			действия, которые ранее пропускал. Если строгий режим был включён, то отключить его для файла уже нельзя.</p>
		<h2 id="expressions">Выражения</h2>
		<h3 id="expression-statement">Что такое выражения и инструкции? В чем отличия между ними?</h3>
		<p><b>Выражение (expression)</b>— это код, который после выполнения возвращает какое-либо значение. Например, 5 +
			3 вернёт 8, а Math.random() — случайное число.</p>
		<p><b>Инструкция (statement)</b>— это отдельная команда в коде, которая выполняет определённое действие. Например,
			if позволяет создать ветвление в программе, for позволяет повторять одно и то же действие. В JavaScript все
			инструкции можно поделить на несколько категорий:
		<pre>
			управление потоком выполнения (if и else, switch, throw и т.д.)
			итерации (for, while и т.д.)
			объявление значений (var, let, const)
			функции (function, return и т.д.)
			прочие (debugger, import, export)</p>
		</pre>
		<h3 id="var-let-const">Чем отличаются var, let, const? Почему использование const может быть предпочтительнее?
		</h3>
		<p>Объявление переменных при помощи ключевого слова var было в JavaScript с первых версий. Переменные var можно
			объявлять без присвоения им значения, в таком случае они будут равны undefined. Переменные, объявленные через
			var, имеют функциональную область видимости. Они доступны только в пределах текущей функции или глобального
			объекта, если функции нет. К переменным, объявленным при помощи ключевого слова var, можно обращаться до
			момента объявления. В отличие от let и const ошибки это не вызовет. Данное поведение называется hoisting -
			«всплытие»</p>
		<p>Значение в переменной, созданной через let можно изменять. Стартовое значение const изменить нельзя, будь то
			примитивное значение или ссылка на объект. Однако объект, хранящийся в const можно мутировать. Объекты хранятся
			по ссылке и изменение объекта не приводит к изменению ссылки на него. Используя ключевое слово let можно
			объявить переменную без присвоения ей начального значения. В таком случае она будет равна undefined. При помощи
			const нельзя объявлять переменные без значения. К переменным let и const нельзя обращаться до их объявления в
			коде.
		</p>
		<p> В новом коде используйте только let или const. Используйте let в тех случаях, когда значение переменной
			меняется. Во всех остальных используйте const. Проще всего всегда по умолчанию использовать ключевое слово
			const и исправлять объявление переменной на let если появляется нужда изменить её значение далее в коде</p>
		<p>Зачем нужны константы? Константы защищают код от случайной перезаписи важных значений. Применяют константы в
			двух случаях:
		<ul>
			<li>мы хотим объявить переменную, которая хранит фундаментальное значение для программы. Например, количество
				дней в году, минимальную сумму заказа, форматы дат и т.д.</li>
			<li>мы объявляем переменную и устанавливаем ей значение всего один раз</li>
		</ul>
		</p>
		<h3 id="ternar">Что такое тернарный оператор?</h3>
		<p>Тернарный оператор работает с тремя операндами: одним условием и двумя выражениями. Возвращает первое
			выражение, если условие истинно и второе, если условие ложно: (A) ? (B) : (C). Используется как компактная
			замена условного
			оператора if.</p>
		<h3 id="for-in">Что делает оператор for..in? Какие имеются особенности при использовании этого оператора с
			массивами?</h3>
		<p>Позволяет пройти в цикле по перечисляемым свойствам объекта, в том числе по свойствам из прототипа.</p>
		<p>Перечисляемые свойства объекта – это свойства, которые явно помечены такими. Сказать свойству, что оно
			перечисляемое, можно через специальный метод defineProperty. Но для простоты все свойства, которые добавляются
			к объекту, являются перечисляемыми по умолчанию. Встроенные свойства не перечисляется. Например метод indexOf у
			объекта String или метод toString у любого объекта не участвуют в цикле for...in.</p>
		<p>В цикле будут перечислены не только собственные свойства объекта, но и все перечисляемые свойства из прототипа
			объекта и прототипа прототипа и так далее.</p>
		<p>Порядок перечисления: строковые имена свойств перечисляются в порядке их присвоения к объекту, числовые - в
			отсортированном порядке по возрастанию. <b>Несмотря на договорённости о порядке вывода числовых ключей, не
				нужно использовать for...in для перебора массива. В будущем правила могут измениться. Для перебора у массива
				есть собственные методы: forEach, map и другие. В этих методах порядок перебора гарантирован.</b></p>
		<h3 id="check-var">Как безопасно проверить, что переменная существует (была объявлена), и не словить
			ReferenceError?</h3>


		<pre>
	<code>
		===============================================================
		
		try {
			if (typeof a === 'undefined') {
				console.log('Не определена');
			} else console.log(a);
		} catch (e) { console.log('Определена после проверки'); }
		//Не определена

		===============================================================
		
		let b;
		try {
			if (typeof b === 'undefined') {
				console.log('Не определена');
			} else console.log(b);
		} catch (e) { console.log('Определена после проверки'); }
		//Не определена

		===============================================================

		try {
			if (typeof c === 'undefined') {
				console.log('Не определена');
			} else console.log(c);
		} catch (e) { console.log('Определена после проверки'); }
		let c;
		//Определена после проверки

		===============================================================

		let d = 10;
		try {
			if (typeof d === 'undefined') {
				console.log('Не определена');
			} else console.log(d);
		} catch (e) { console.log('Определена после проверки'); }
		// 10

		===============================================================
	</code>
</pre>
		<script>
			'use strict'
			let a = 10;
			try {
				if (typeof a === 'undefined') {
					console.log('Не определена');
				} else console.log(a);
			} catch (e) { console.log('Определена после проверки'); }
			//let a;
		</script>
		<h2 id="arrays">Массивы</h2>
		<h3 id="array-create">Способы создания массивов (литерал, конструктор, фабричные методы Array.from() и
			Array.of());</h3>
		<p>Литерал массива — это список из нуля или более выражений, каждое из которых представляет элемент массива,
			заключенный в квадратные скобки ( [] ). Когда вы создаете массив, используя литерал массива, он
			инициализируется с помощью переданных значений, которые будут являться его элементами, длина массива будет
			равна числу переданных аргументов. Синтаксис: let arr = [element0, element1, ..., elementN]</p>
		<p>Конструктор Array(). Синтаксис: const arr = new Array(element0, element1[, ...[, elementN]]); elementN —
			элементы, из которых создаётся массив.
			Или const arr = new Array(arrayLength), arrayLength — длина массива (количество элементов )</p>
		<p>Метод Array.of() создает новый массив из произвольного числа аргументов, независимо от их количества и типа.
			Разница между Array.of() и конструктором Array состоит в обработке единственного аргумента, являющегося целым
			числом:
			Array.of(7) создает массив с одним элементом, тогда как Array(7) создает пустой массив, у которого свойство
			length равно 7 (имеется в виду массив из 7 пустых слотов, а не слотов, содержащих значение undefined)</p>

		<p>Array.of(7); // [7]
			Array(7); // array of 7 empty slots</p>
		<p>Array.of(1, 2, 3); // [1, 2, 3]
			Array(1, 2, 3); // [1, 2, 3]</p>
		<h3 id="arr-delete-item">Удаление элемента из массива (какие есть способы и в чем особенности);</h3>

		<p>1. Метод <b>delete</b> (delete arr[1]). При его использовании длина массива не
			изменится. Удаление методом delete нормально для объектов, но для массивов мы обычно хотим, чтобы оставшиеся
			элементы сдвинулись и заняли освободившееся место. Мы ждём, что массив станет короче.
			Поэтому для этого нужно использовать метод <b>splice</b>.</p>
		<p>2. Метод <b>splice</b>. Синтаксис: <b>arr.splice(index[, deleteCount, elem1, ..., elemN])</b>. Он начинает с
			позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место.
			Возвращает массив из удалённых элементов. Метод splice также может вставлять элементы без удаления, для этого
			достаточно установить deleteCount в 0</p>

		<p></p>

		<h3 id="arr-length">Свойство length у массива</h3>
		<h4>Какое значение будет у свойства length массива a и почему:</h4>
		<pre><code>
		const a = [1, 2, 3];
		a[10] = 4;
	</code></pre>
		<p>Ответ: свойство length будет равно 11, потому что между последним элементом (3) и новым (4) появилась «дыра» из
			семи пустых ячеек: [1, 2, 3, empty × 7, 4]</p>
		<h4>Что будет, если переприсвоить новое значение?</h4>
		<p>Свойство length перезаписываемое, вы можете записать в него любое число из диапазона возможных значений. Это
			изменит количество ячеек массива. Если уменьшить значение свойства length, то из конца массива будут отброшены
			элементы, которые не входят в новый размер массива. Если увеличить значение свойства length, то в конец массива
			добавятся пустые ячейки массива. Значение в них не будет установлено и они будут игнорироваться при обходе
			массива. Не записывайте вручную значения в length. Хотя это и возможно, на практике такой код плохо читается.
			Он может неприятно удивить других разработчиков из-за того, что изменяет размер массива. Об этом побочном
			эффекте знают не все.
		</p>
		<h4>Влияет ли на length удаление элемента посередине массива? Какие способы удаления элементов влияют на длину, а
			какие нет?</h4>
		<p>Зависит от того, как удален элемент. Если удалять методом <b>delete</b> (delete arr[1]), то длина массива не
			изменится. Удаление методом delete нормально для объектов, но для массивов мы обычно хотим, чтобы оставшиеся
			элементы сдвинулись и заняли освободившееся место. Мы ждём, что массив станет короче.
			Поэтому для этого нужно использовать метод <b>splice</b>. Его синтаксис:</p>
		<p>arr.splice(index[, deleteCount, elem1, ..., elemN])</p>
		<p>Он начинает с позиции index, удаляет deleteCount элементов и вставляет elem1, ..., elemN на их место.
			Возвращает массив из удалённых элементов. Метод splice также может вставлять элементы без удаления, для этого
			достаточно установить deleteCount в 0</p>


		<h3 id="check-arr">Как проверить, что в переменной лежит массив?</h3>
		<p>Метод Array.isArray() проверяет, является ли переданный аргумент массивом. Возвращает true, если является, и
			false — если нет.</p>

		<h3 id="arr-methods">Что делают, как и когда использовать следующие методы</h3>

		<h4>reduce</h4>
		<p>Позволяет превратить массив в любое другое значение с помощью переданной функции-колбэка и начального значения.
			Функция-колбэк будет вызвана для каждого элемента массива и всегда должна возвращать результат. Метод reduce
			принимает два параметра: функцию-колбэк и начальное значение для аккумулятора.
		<ul>Сама функция-колбэк может принимать четыре параметра:
			<li>acc — текущее значение аккумулятора</li>
			<li>item — элемент массива в текущей итерации</li>
			<li>index — индекс текущего элемента</li>
			<li>arr — сам массив, который мы перебираем</li>
		</ul>
		</p>

		<h4>sort</h4>
		<p>Cортирует массив, меняя в нём порядок элементов. Он возвращает отсортированный массив, но обычно возвращаемое
			значение игнорируется, так как изменяется сам arr. Принимает коллбэк, описывающий, как должны сортироваться
			значения. Функция должна для пары значений возвращать:</p>
		<pre><code>
		function compare(a, b) {
		if (a > b) return 1; // если первое значение больше второго
		if (a == b) return 0; // если равны
		if (a < b) return -1; // если первое значение меньше второго } 
		</code></pre>
		<p>По умолчанию (если коллбэк не передан) элементы сортируются как строки.</p>



		<p>Все указанные методы принимают коллбэк-функцию,
			которая принимает три параметра: item — элемент массива в текущей итерации; index — индекс текущего элемента;
			arr — сам массив, который мы перебираем.</p>

		<h4>filter</h4>
		<p>Позволяет получить новый массив, отфильтровав элементы с помощью переданной колбэк-функции. Колбэк-функция
			будет вызвана для каждого элемента массива и по результату функции примет решение включать этот элемент в новый
			массив или нет.</p>
		<p>Аналогично методу forEach, методу filter необходимо передать аргументом функцию. Главное отличие — функция
			должна возвращать boolean, т. е. результатом должен быть true или false. Такие функции называют предикатами.
		</p>



		<h4>map</h4>
		<p>Метод map позволяет трансформировать один массив в другой при помощи функций-колбэка. Переданная функция
			будет вызвана для каждого элемента массива по порядку. Из результатов вызова функции будет собран новый массив.
			map возвращает новый массив, при этом исходный массив никак не изменится. При работе с map необходимо
			возвращать
			значение из функции-колбэка. Если не вернуть значение — например, забыв обработать какую-то ветку условия,
			то в итоговом массиве будет undefined</p>

		<h4>forEach</h4>
		<p>Выполняет функцию-коллбэк один раз для каждого элемента массива. Массив, к которому применяется метод, не
			изменяется</p>

		<h4>some</h4>
		<p>Позволяет узнать, есть ли в массиве хотя бы один элемент, удовлетворяющий условию в
			функции-колбэке. Колбэк-функция будет вызвана для каждого элемента массива до тех пор пока не вернётся true,
			либо пока не закончатся элементы массива. Результатом вызова метода Array.some будет boolean-значение true или
			false. Если ни один элемент в массиве не
			удовлетворит условию, то результат будет false.</p>

		<h4>every</h4>
		<p>Позволяет узнать, удовлетворяют ли все элементы в массиве условию в функции-колбэке. Результатом вызова метода
			Array.every будет boolean-значение true или false. Если хотя бы один элемент не будет удовлетворять условию, то
			результат будет false. <b>Проверка пустого массива всегда вернёт true</b></p>
		<h2 id="functions">Функции</h2>
		<h3 id="function-invocation">Какие есть 4 шаблона вызова функции, которые задают контекст выполнения этой функции?
		</h3>
		<p>Вызов функции — Function Invocation. Значение this будет ссылаться на глобальный объект (window) в нестрогом
			режиме. В строгом режиме this равен undefined</p>
		<p>Вызов метода — Method Invocation. Значение this будет ссылаться на объект, которому принадлежит метод</p>
		<p>Вызов конструктора — Constructor Invocation. This в данном случае будет относиться к свежесозданному объекту
		</p>
		<p>Вызов apply и call — Apply And Call Invocation. Позволяет вручную запустить функцию, попутно снабдив ее
			параметрами и обозначив this. Синтаксис: func.call(obj, 1, 2, 3); func.apply(obj, [1, 2, 3]);</p>
		<h4>Как директива use strict влияет на this внутри функции?</h4>
		<p>При включённом строгом режиме this больше не будет по умолчанию ссылаться на глобальный объект. This по
			умолчанию будет равен undefined</p>
		<h3 id="function-many-args">Какой наиболее простой паттерн, позволяющий облегчить читаемость функции, когда у нее
			огромное количество аргументов?</h3>
		<p>Ответ: использовать спред-синтаксис ...</p>
		<p>спред-синтаксис:
		<pre>
				<code>
			function multiplyThreeNumbers(a, b, c) {
			return a * b * c
				}
			const nums = [1, 2, 3, 5, 6]
			console.log(multiplyThreeNumbers(...nums))
			 // 6
				</code>
			</pre>


		</p>
		<h3>Как получить все аргументы функции (включая те, что не объявлены, но все-таки были переданы)?</h3>
		<p>Ответ: использовать остаточные параметры или переменную arguments (устаревший способ)
		<p>Остаточные параметры могут быть обозначены через три точки .... Буквально это значит: «собери оставшиеся
			параметры и положи их в массив».</p>
		<pre><code>
				function sumAll(...args) { // args — имя массива
					let sum = 0;
				 	for (let arg of args) sum += arg;
				 	return sum;
				 }
			</code></pre>
		</p>
		<p>Мы можем положить первые несколько параметров в переменные, а остальные – собрать в массив.
			В примере ниже первые два аргумента функции станут именем и фамилией, а третий и последующие превратятся в
			массив titles:
		<pre><code>
			function showName(firstName, lastName, ...titles) 
			{// some code}
		</code></pre>
		</p>
		<p>Arguments. Все аргументы функции находятся в псевдомассиве arguments под своими порядковыми номерами, к ним
			можно обратиться в теле функции. Недостаток этого подхода: хотя arguments похож на массив, и его тоже можно
			перебирать, это всё же не массив. Он не поддерживает методы массивов</p>

		<h3 id="closure">Что такое замыкания, и в каких случаях они могут быть полезны? Как сохранить состояние с помощью
			замыкания, и
			для чего это состояние может быть использовано?</h3>
		<h3 id="bind">Как реализовать функцию bind?</h3>
		<p>Это метод, который позволяет связывать контекст выполнения с функцией, чтобы «заранее и точно» определить,
			какое именно значение будет у this.
		<pre><code>
			function greet() {
				console.log(`Hello, ${this.name}`)
			 }
			 
			 const user1 = { name: "Alex" }
			 
			 const greetAlex = greet.bind(user1)
			 greetAlex() // Hello, Alex
			 
		</code></pre>
		</p>
		<h3 id="problem">Решить такую вот проблему: пускай у нас есть массив ссылок, и наша задача — сделать так, чтобы
			при клике на
			каждую выводился alertом ее порядковый номер. Первое решение, что приходит в голову, выглядит так:</h3>
		<a class="link" href="">link 1</a>
		<a class="link" href="">link 2</a>
		<a class="link" href="">link 3</a>
		<a class="link" href="">link 4</a>
		<a class="link" href="">link 5</a>

		<pre><code>
				for (var i = 0; i < links.length; i++) {
					links[i].onclick = function() {
						alert(i);
					}
				}
			</code></pre>
		<p>На деле же оказывается, что при клике на любую ссылку выводится одно и то же число — значение links.length.
			Почему так происходит и как эту гадость исправить?</p>
		<p>Ответ: в замыкании обработчика щелчка хранится ссылка на переменную i, а не фактическое значение i .

			Каждый обработчик щелчка будет ссылаться на один и тот же объект, потому что есть только один объект счетчика,
			который содержит i (5), поэтому вы получаете пять при каждом щелчке. Для достижения желаемого поведения
			необходимо var заменить на let</p>
		<script>
			const links = document.querySelectorAll('.link');
			for (var i = 0; i < links.length; i++) {
				links[i].onclick = function () {
					alert(i);
				}
			}
		</script>

		<h3 id="callback">Что такое callback (функция обратного вызова)? Когда они обычно применяются?</h3>
		<p>В функции, которые выполняют какие-либо асинхронные операции, передаётся аргумент callback — функция, которая
			будет вызвана по завершению асинхронного действия.</p>
		<h3 id="curry">Что такое каррирование?</h3>

		<h3 id="part">Что такое частичное применение?</h3>
		<h3 id="memo">Что такое мемоизация?</h3>




	</main>

</body>

</html>