<!doctype html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <script defer src="./main.js"></script>
  <link rel="stylesheet" href="./ts.css">
</head>

<body style="padding: 10px; border: 1px solid rgb(204, 199, 199); box-shadow: 0 0 10px 10px rgb(204, 199, 199);">
  <main style="margin: 0 auto; max-width: 2400px; width: 100%;">
    <p>
      Содержание
    <ul>
      <li>
        <a href="#what-is-ts">Что такое TypeScript? Для чего он нужен и какие проблемы решает?</a>
      </li>
      <li>
        <a href="#typing">Рассказать про следующие виды типизации, их особенности, плюсы и минусы</a>
      </li>
      <li>
        <a href="#js-ts-typing">Какие виды типизации используются в JavaScript и TypeScript?</a>
      </li>
      <li>
        <a href="#data-types">Как и для каких целей используются типы данных, приведенные ниже?</a>
      </li>
      <li>
        <a href="#interfaces">Для чего предназначены интерфейсы?</a>
      </li>
      <li>
        <a href="#type-aliases">Что такое Type Aliases? Зачем нужны? Чем отличаются от интерфейсов?</a>
      </li>

      <li>
        <a href="#Union-intersection">Union и intersection типы</a>
      </li>

      <li>
        <a href="#class-implements-extends">Может ли класс одновременно реализовывать набор интерфейсов и наследоваться
          от другого класса?</a>
      </li>

    </ul>
    </p>
    <h1 id="ts">TS</h1>
    <h2 id="what-is-ts">Что такое TypeScript? Для чего он нужен и какие проблемы решает?</h2>
    <p>TypeScript — это язык программирования со статической типизацией, позиционирующий себя как язык, расширяющий
      возможности JavaScript.</p>
    <ul>Какие проблемы решает:

      <li>Выявление ошибок на этапе компиляции, а не на этапе выполнения</li>
      <li>За счет системы типов разработчики получают такие возможности, как подсказки и переходы по коду, которые
        значительно ускоряют процесс разработки</li>
      <li>Система типов в значительной степени избавляет разработчиков от комментирования кода, которое отнимает
        значительное время</li>
      <li>Система типов помогает раньше выявлять проблемы архитектуры, исправление которых обходятся дешевле на ранних
        этапах</li>
    </ul>
    <h2 id="typing">Рассказать про следующие виды типизации, их особенности, плюсы и минусы</h2>
    <h3>Слабая / сильная</h3>
    <p><b>Сильная типизация:</b> НЕ разрешает выполнение выражений с несовместимыми типами и не выполняют неявное
      преобразование типов в ситуациях, когда нужно выполнять преобразование явно.</p>
    <ul>Плюсы:
      <li>при операциях способных привести к потере или порче значения возникает ошибка. Благодаря этому сильно
        типизированные языки в меньшей степени подвержены багам.</li>
    </ul>
    <p><b>Слабая типизация:</b> разрешают выполнение выражений с любыми типами и самостоятельно выполняют неявное
      преобразование</p>
    <ul>Минусы:
      <li>Из-за того, что в языках со слабой типизацией допускаются неявные преобразования существует высокая
        вероятность возникновения трудно выявляемых багов. Причиной появления подобных багов является отсутствие
        возникновения ошибок в некоторых операциях неявного преобразования. Программа получает данные ожидаемого типа,
        но непредсказуемого значения</li>
    </ul>
    <h3>Статическая / динамическая</h3>
    <p><b>Статическая типизация:</b> контроль типов происходит на этапе компиляции. </p>
    <p>Особенности. До того момента, как программа будет запущена, компилятор осуществляет проверку совместимости типов,
      участвующих в различных операциях. Все конструкции, нуждающиеся в аннотации типа,
      связываются с типом данных при объявлении. При этом связь с типом данных в дальнейшем не может быть изменена</p>
    <ul>Плюсы:
      <li>За счет того, что большая часть проверок происходит на этапе компиляции, программа обладает большей
        производительностью из-за отсутствия проверок во время выполнения</li>
      <li>Языки со статической проверкой типов значительно повышают семантическую привлекательность кода делая его более
        читабельным</li>
      <li>Благодаря статическому контролю типов, редактор кода способен на основе синтаксического анализа выводить
        вспомогательную информацию, ускоряющую разработку</li>
    </ul>
    <p><b>Динамическая типизация:</b> контроль типов происходит на этапе выполнения программы. </p>
    <p>Особенности: конструкция нуждающаяся в аннотации типа, связывается с типом данных на этапе выполнения программы в
      момент присвоения значения. При этом связь с типом данных может быть изменена. Тип данных может быть определен
      только на основании вычисленного результата выражения. При этом операция присвоения значения может изменить тип
      данных сущности с которым она была связана ранее. Динамический контроль типов проверяет операнды на совместимость
      типов и совместимость с оператором в каждой отдельной операции. </p>
    <ul>Плюсы:</ul>
    <ul>Минусы:
      <li>Проверка типов данных во время выполнения программы отрицательно сказывается на её производительности. Поэтому
        языки с динамическим контролем типов проигрывают в производительности языкам со статическим контролем типов у
        которых совместимость проверяется на этапе компиляции.</li>
      <li>По причине выявления несовместимости типов только во время выполнения программы ошибки выявляются менее
        эффективно. Программа не узнает о скрывающейся в ней ошибке, пока не дойдет очередь выполнения проблемного
        участка кода.</li>
      <li>Редакторы кода, даже современные, испытывают трудности при синтаксическом анализе кода</li>
    </ul>
    <h3>явная/неявная</h3>
    <p><b>Явная типизация:</b> типы языковых элементов (сигнатура функций и т.д.) явно прописывается в коде. </p>
    <ul>Плюсы:
      <li>делает код более понятным (читабельным)</li>
      <li>способствует развитию у разработчика навыков необходимых для проектирования архитектуры программ</li>
    </ul>
    <p><b>Неявная типизация:</b> типы языковых элементов не прописывается в коде </p>
    <ul>Плюсы:
      <li>более лаконичный код</li>
    </ul>
    <ul>Минусы:
      <li>труднее разобраться в коде</li>
    </ul>

    <h3>Структурная / номинативная</h3>
    <p><b>Структурная типизация:</b> определяет совместимость типов основываясь не на иерархии наследования или явной
      реализации интерфейсов, а на их описании. Компилятор считает типы совместимыми, если сопоставляемый тип имеет все
      признаки типа, с которым сопоставляется. Чтобы быть совместимым, сопоставляемый тип должен иметь те же ключи с
      теми же (идентичными или совместимыми) типами, что и тип, с которым происходит сопоставление</p>
    <p><b>Номинативная типизация:</b> устанавливает совместимость типов основываясь на идентификаторах типов (ссылках).
      При проверке на совместимость компилятор проверяет иерархию типов на признаки наследования и
      реализацию интерфейсов. То есть, тип B будет совместим с типом A только тогда, когда он является его предком
      (extends). Кроме того, тип B будет совместим с интерфейсом IA только в том случае, если он или один из его предков
      реализует его явно (implements)</p>
    <p>Как работает структурная типизация в Typescript:</p>
    <pre><code>
    class Car {
      id: number;
      numberOfWheels: number;
      move (x: number, y: number) {
          // некая реализация
      }
  }
    
    class Boat {
        id: number;
        move (x: number, y: number) {
            // некая реализация
        }
    }
    
    let car: Car = new Boat(); // здесь TypeScript выдаст ошибку, в Boat отсутствует свойство numberOfWheels
    let boat: Boat = new Car(); // а на этой строчке все в порядке - Класс Car содержит все свойства и методы класса Boat, поэтому Car может использоваться в качестве Boat
    </code></pre>


    <h2 id="js-ts-typing">Какие виды типизации используются в JavaScript и TypeScript?</h2>

    <p><b>JavaScript:</b> Динамическая | Слабая | Неявная</p>
    <p><b>TypeScript:</b> Статическая | Сильная | Явная | Структурная (???????????)</p>


    <h2 id="data-types">Как и для каких целей используются типы данных, приведенные ниже?</h2>
    <h3>Boolean</h3>
    <p></p>
    <h3>Number</h3>
    <p></p>
    <h3>String</h3>
    <p></p>
    <h3>Null and Undefined</h3>
    <p></p>
    <h3>Object and object</h3>
    <p></p>
    <h3>Array</h3>
    <p></p>
    <h3>Tuple</h3>
    <p></p>
    <h3>Enum</h3>
    <p>Enum — это конструкция, состоящая из набора именованных констант, именуемая списком перечисления и определяемая
      такими примитивными типами, как number и string. Enum объявляется с помощью ключевого слова enum</p>
    <h3>Any</h3>
    <p>Используетя, если тип конструкций может быть неизвестен. Примером этого может служить сервис, который работает с
      сервером посредством api. Полученные и сериализованные данные могут храниться как тип any прежде чем они будут и
      преобразованы к конкретному типу.</p>
    <p>Тип any является уникальным для TypeScript, в JavaScript подобного типа не существует. Any является базовым для
      всех остальных типов. Все типы в TypeScript являются его подтипами. Это означает, что он совместим в обе стороны с
      любым другим типом и с точки зрения системы типов является высшим типом (top type).</p>
    <h3>Void</h3>
    <p>Тип данных Void можно назвать полной противоположностью типа any, так как этот тип означает отсутствие
      конкретного типа. Основное предназначение типа Void — явно указывать на то, что у функции или метода отсутствует
      возвращаемое значение.</p>
    <h3>Never</h3>
    <p>Примитивный типа данных Never служит для указания того, что какие-либо операции никогда не будут выполнены.</p>
    <h3>Unknown</h3>
    <p>Тип Unknown является типобезопасным аналогом типа any и представлен в виде литерала unknown. Тип unknown
      позволяется использовать только в операциях равенства ===, ==, !== и != и в операциях с логическими операторами
      &&, || и !.</p>




    <h2 id="Union-intersection">Union и intersection типы</h2>
    <h3>Для чего нужны?</h3>
    <p>Позволяют скомбинировать существующие типы вместо того, чтобы создать их с нуля</p>
    <h3>Как использовать?</h3>
    <p> <b> Объединение (Union) </b>— это механизм, позволяющий создавать из множества существующих типов логическое
      условие, по которому данные могут принадлежать только к одному из указанных типов. Объединение указывается с
      помощью оператора прямой черты |, по обе стороны которой располагаются типы данных.</p>
    <pre><code>
        let v1: T1 | T2 | T3;
      </code></pre>
    <p>Переменной, которой был указан тип объединения A или B или C, может быть присвоено значение, принадлежащие к
      одному из трех типов.</p>

    <p> <b>Пересечение (Intersection)</b> — ещё один механизм TypeScript, который позволяет рассматривать множество
      типов
      данных как единое целое. Пересечение указывается с помощью оператора амперсанда & по обе стороны от которого
      указываются типы данных.</p>
    <pre><code>
        let v1: T1 & T2 & T3;
      </code></pre>
    <p>Переменной, которой был указан тип пересечение A и B и С должно быть присвоено значение принадлежащее к типам A и
      B и C одновременно. Другими словами значение должно обладать всеми обязательными признаками каждому типа
      определяющего пересечение.</p>
    <b> Пояснение человеческим языком <a
        href="https://ru.stackoverflow.com/questions/876192/%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%B2-typescript-%D0%BF%D0%B5%D1%80%D0%B5%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-%D1%82%D0%BE-%D1%87%D1%82%D0%BE-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-%D0%BE%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8-%D0%BC%D0%BD">Читать
        здесь >></a> и <a
        href="https://stackoverflow.com/questions/38855908/naming-of-typescripts-union-and-intersection-types">здесь</a></b>

    <h2 id="interfaces">Для чего предназначены интерфейсы?</h2>
    <p> <b>Interface</b> — это синтаксическая конструкция, предназначенная для описания открытой (public) части объекта
      без реализации (api).</p>
    <p>Интерфейс предназначен для описания состояния и поведения объекта, класса, функционального выражения (какие
      свойства и методы он содержит, какие типы они возвращают и т.д.).</p>
    <p>Интерфейс объявляется с помощью ключевого слова interface, после которого указывается идентификатор (имя), за
      которым следует заключенное в фигурные скобки тело содержащее описание.</p>
    <pre><code>
        interface Identifier {
          // тело интерфейса 
      }
      </code></pre>


    <h2 id="type-aliases">Что такое Type Aliases? Зачем нужны? Чем отличаются от интерфейсов?</h2>

    <p>Псевдоним типа объявляется при помощи ключевого слова type, после которого следует идентификатор (имя)
      псевдонима, а за ним идет оператор присваивания =, справа от которого находится тип, ассоциирующийся с
      псевдонимом. Например:
    </p>
    <pre><code>
    class Type {
      method(): void {
          type Alias = Type;
      }
  }
    type Alias = Type;
    </code></pre>
    <p>Разберем разницу между интерфейсом и типом в TS. С выходом новых версий TS отличия между ними очень сильно
      размываются и уже давно тип и интерфейс являются взаимозаменяемыми почти во всех случаях. Интерфейс и тип мы можем
      использовать для описания свойств объекта:</p>


    <pre><code>
  interface UserA {
    name: string;
    age: number
  }

  type UserB = {
    name: string;
    age: number
  }

const user1: UserA  = {
  name: 'Ivan',
  age: 20
}

const user2: UserB  = {
  name: 'Petr',
  age: 30
}

</code></pre>


    <p> В данном случае они будут полностью взаимозаменяемы. Разница только в синтаксисе. Интерфейс объявляется в
      синтаксисе похожем на класс, а тип - в синтаксисе похожем на объект.</p>
    <p>Также и тип и интерфейс можно использовать для описания поведения функции. Разницы никакой нет, сигнатура
      осталась той же:</p>


    <pre><code>
  interface SumA {
    (a: number, b: number): number
  }

  type SumB = (a: number, b: number) => number; 

  const sum1: SumA = (a, b) => a + b;
  const sum2: SumB = (a, b) => a + b;

</code></pre>
    <p> В старых версиях TS нельзя было наследоваться интерфейсом от типа, но в последних версиях это возможно (если это
      объектный тип (object type) или пересечение объектных типов со статически известными членами):</p>

    <pre><code>
    type B = {
    name: string;
    }

    interface A extends B {} // интерфейс наследуется от типа

    const B: A = {
    name: 'Lena';
    }
    </code></pre>


    <p>Как видим, в большинстве случаев интерфейсы и типы являются взаимозаменяемыми</p>
    <p>Различия:</p>
    <p><b>1) с помощью типа можно сделать alias для какого-то примитивного значения:</b></p>
    <pre><code>
  type UniqueID = string;
</code></pre>
    <p>Далее чтобы писать более понятные типы, его можно использовать в других интерфейсах для большего понимания, что
      происходит в системе:</p>
    <pre><code>
interface User {
  id: UniqueID
}
</code></pre>
    <p>Alias примитива можно сделать только с помощью типа. Но если это alias не для примитивного значения, а например
      для массива, то можно использовать и интерфейс</p>
    <pre><code>
  type NamesA = string[];
  interface NamesB { // Здесь определен интерфейс, который содержит сигнатуру массива. Эта сигнатура указывает, что объект, который реализует NamesB, может индексироваться с помощью чисел (объекта типа number). И, кроме того, данный объект должен хранить объекты типа string, то есть строки.
    [key]: number: string 
  }
</code></pre>

    <p><b>2) с помощью интерфейса невозможно описать тип кортежа (кортеж это массив, длина которого не изменяется)</b>
    </p>

    <pre><code>
  type State = [number, (a: number) => void]
  const tup = [123, (n) => {}]
  </code></pre>
    <p><b>3) мы можем создать тип, который будет частично имплементировать другой тип</b></p>

    <pre><code>
  type UserA = {
    name: string;
  }

  type UserB = {
    age: number
  }

  type C = A | B;

const obj1: C = { // ok
  name: 'S',
}
const obj2: C = { // ok
  age: 10,
}
const obj3: C = { // надо проверить, может ли объект содержатьоба свойства
  name: 'S',
  age: 10,
}
</code></pre>
    <p>Написать подобный интерфейс невозможно</p>

    <pre><code>
  interface D extends A | B {} // невалидный код
  interface D extends C {} // невалидный код, т.к. экстендиться от типа, который содержит внутри себя union, невозможно
  interface D extends A, B {} // ok, но тогда обязательными будут оба поля
</code></pre>
    <p><b>4) Типы, в отличие от интерфейсов, не могут быть объявлены несколько раз</b></p>
    <pre><code>
 type A = {
   age: number
 }

 type A = { // ошибка
  name: string
}

interface B = {
  age: number
}

interface B = { // ok, произошел automerge, расширение интерфейса. Теперь объект с интерфейсом B должен иметь два поля
 name: string
}
  
const obj: B = {
  age: 20,
  name: 'Masha'
}
</code></pre>

    <p><b>5) Псевдонимы типов нельзя использовать в таких операциях с типами времени выполнения как typeof и instanceof
        - ??????? ЧТО ЭТО ЗНАЧИТ?????</b></p>






    <h2 id="class-implements-extends">Может ли класс одновременно реализовывать набор интерфейсов и наследоваться от
      другого класса?</h2>
    <p>Может:</p>

    <pre><code>
        interface IAnimal {}
        interface IOviparous {} 
        
        class Bird implements IAnimal, IOviparous {} 
        
        interface IFlyable {}
        interface IPredatory {}
        
        class Eagle extends Bird implements IFlyable, IPredatory {} //надо проверить, может ли класс, наследующийся от другого класса, реализовывать более одного интерфейса (наверное может)
      </code></pre>
    <h2>От чего могут наследоваться интерфейсы? Какие накладывает ограничения наследование от класса?</h2>
    <p>Наследование интерфейсов осуществляется с помощью ключевого слова extends, после которого через запятую идет один
      или несколько идентификаторов расширяемых интерфейсов / типов / классов</p>
    <p> <b>От других интерфейсов</b> </p>
    <pre><code>
      interface IIdentifiable {}
      interface ILiving {}
      
      // интерфейсы IIdentifiable и ILiving вместе образуют логически связанную композицию, 
      // которую можно выделить в интерфейс IAnimal
      interface IAnimal extends IIdentifiable, ILiving {}
    </code></pre>

    <p><b>От типов</b></p>
    <p> В старых версиях TS нельзя было наследоваться интерфейсом от типа, но в последних версиях это возможно (если это
      объектный тип (object type) или пересечение объектных типов со статически известными членами):</p>

    <pre><code>
    type B = {
    name: string;
    }

    interface A extends B {} // интерфейс наследуется от типа

    const B: A = {
    name: 'Lena';
    }
    </code></pre>
    <pre><code>
  
    </code></pre>

    <p><b>От классов</b></p>
    <pre><code>
      class Animal {
        nickname: string;
        age: number;
    }
    
    interface IAnimal extends Animal {} //интерфейс наследуется от класса
    
    class Bird implements IAnimal {
        nickname:string;
        age: number;
    }
    
    let bird: IAnimal = new Bird();
    </code></pre>

    <p>Интерфейс, полученный путем расширения типа класса, может быть реализован только самим этим классом или его
      потомками, поскольку помимо публичных (public) также наследует закрытые (private) и защищенные (protected) члены.
    </p>
    <pre><code>
    class Animal {
      private uid: string;
      protected maxAge: number;
      public name: string;
  }
  
    interface IAnimal extends Animal {}
    
    class Bird extends Animal implements IAnimal { // Ok
        // private uid: string = ''; // Error, private
        protected maxAge: number = 100; // Ok, protected
        public name: string = 'bird'; // Ok,  public
    }
    
    class Fish implements IAnimal { // Error
        public name: string = 'fish';
    }
    
    let bird: IAnimal = new Bird(); // Ok
    let fish: IAnimal = new Fish(); // Error
    </code></pre>

  </main>

</body>

</html>