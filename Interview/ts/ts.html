<!doctype html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <script defer src="./main.js"></script>
  <link rel="stylesheet" href="./ts.css">
</head>

<body style="padding: 10px; border: 1px solid rgb(204, 199, 199); box-shadow: 0 0 10px 10px rgb(204, 199, 199);">
  <main style="margin: 0 auto; max-width: 2400px; width: 100%;">
    <p>
      Содержание
    <ul>
      <li>
        <a href="#what-is-ts">Что такое TypeScript? Для чего он нужен и какие проблемы решает?</a>
      </li>
      <li>
        <a href="#typing">Рассказать про следующие виды типизации, их особенности, плюсы и минусы</a>
      </li>
      <li>
        <a href="#js-ts-typing">Какие виды типизации используются в JavaScript и TypeScript?</a>
      </li>
      <li>
        <a href="#data-types">Как и для каких целей используются типы данных, приведенные ниже?</a>
      </li>
      <li>
        <a href="#interfaces">Для чего предназначены интерфейсы?</a>
      </li>
      <li>
        <a href="#type-aliases">Что такое Type Aliases? Зачем нужны? Чем отличаются от интерфейсов?</a>
      </li>

      <li>
        <a href="#Union-intersection">Union и intersection типы</a>
      </li>

      <li>
        <a href="#class-implements-extends">Может ли класс одновременно реализовывать набор интерфейсов и наследоваться
          от другого класса?</a>
      </li>

    </ul>
    </p>
    <h1 id="ts">TS</h1>
    <h2 id="what-is-ts">Что такое TypeScript? Для чего он нужен и какие проблемы решает?</h2>
    <p>TypeScript — это язык программирования со статической типизацией, позиционирующий себя как язык, расширяющий
      возможности JavaScript.</p>
    <ul>Какие проблемы решает:

      <li>Выявление ошибок на этапе компиляции, а не на этапе выполнения</li>
      <li>За счет системы типов разработчики получают такие возможности, как подсказки и переходы по коду, которые
        значительно ускоряют процесс разработки</li>
      <li>Система типов в значительной степени избавляет разработчиков от комментирования кода, которое отнимает
        значительное время</li>
      <li>Система типов помогает раньше выявлять проблемы архитектуры, исправление которых обходятся дешевле на ранних
        этапах</li>
    </ul>
    <h2 id="typing">Рассказать про следующие виды типизации, их особенности, плюсы и минусы</h2>
    <h3>Слабая / сильная</h3>
    <p><b>Сильная типизация:</b> НЕ разрешает выполнение выражений с несовместимыми типами и не выполняют неявное
      преобразование типов в ситуациях, когда нужно выполнять преобразование явно.</p>
    <ul>Плюсы:
      <li>при операциях способных привести к потере или порче значения возникает ошибка. Благодаря этому сильно
        типизированные языки в меньшей степени подвержены багам.</li>
    </ul>
    <p><b>Слабая типизация:</b> разрешают выполнение выражений с любыми типами и самостоятельно выполняют неявное
      преобразование</p>
    <ul>Минусы:
      <li>Из-за того, что в языках со слабой типизацией допускаются неявные преобразования существует высокая
        вероятность возникновения трудно выявляемых багов. Причиной появления подобных багов является отсутствие
        возникновения ошибок в некоторых операциях неявного преобразования. Программа получает данные ожидаемого типа,
        но непредсказуемого значения</li>
    </ul>
    <h3>Статическая / динамическая</h3>
    <p><b>Статическая типизация:</b> контроль типов происходит на этапе компиляции. </p>
    <p>Особенности. До того момента, как программа будет запущена, компилятор осуществляет проверку совместимости типов,
      участвующих в различных операциях. Все конструкции, нуждающиеся в аннотации типа,
      связываются с типом данных при объявлении. При этом связь с типом данных в дальнейшем не может быть изменена</p>
    <ul>Плюсы:
      <li>За счет того, что большая часть проверок происходит на этапе компиляции, программа обладает большей
        производительностью из-за отсутствия проверок во время выполнения</li>
      <li>Языки со статической проверкой типов значительно повышают семантическую привлекательность кода делая его более
        читабельным</li>
      <li>Благодаря статическому контролю типов, редактор кода способен на основе синтаксического анализа выводить
        вспомогательную информацию, ускоряющую разработку</li>
    </ul>
    <p><b>Динамическая типизация:</b> контроль типов происходит на этапе выполнения программы. </p>
    <p>Особенности: конструкция нуждающаяся в аннотации типа, связывается с типом данных на этапе выполнения программы в
      момент присвоения значения. При этом связь с типом данных может быть изменена. Тип данных может быть определен
      только на основании вычисленного результата выражения. При этом операция присвоения значения может изменить тип
      данных сущности с которым она была связана ранее. Динамический контроль типов проверяет операнды на совместимость
      типов и совместимость с оператором в каждой отдельной операции. </p>
    <ul>Плюсы:</ul>
    <ul>Минусы:
      <li>Проверка типов данных во время выполнения программы отрицательно сказывается на её производительности. Поэтому
        языки с динамическим контролем типов проигрывают в производительности языкам со статическим контролем типов у
        которых совместимость проверяется на этапе компиляции.</li>
      <li>По причине выявления несовместимости типов только во время выполнения программы ошибки выявляются менее
        эффективно. Программа не узнает о скрывающейся в ней ошибке, пока не дойдет очередь выполнения проблемного
        участка кода.</li>
      <li>Редакторы кода, даже современные, испытывают трудности при синтаксическом анализе кода</li>
    </ul>
    <h3>явная/неявная</h3>
    <p><b>Явная типизация:</b> типы языковых элементов (сигнатура функций и т.д.) явно прописывается в коде. </p>
    <ul>Плюсы:
      <li>делает код более понятным (читабельным)</li>
      <li>способствует развитию у разработчика навыков необходимых для проектирования архитектуры программ</li>
    </ul>
    <p><b>Неявная типизация:</b> типы языковых элементов не прописывается в коде </p>
    <ul>Плюсы:
      <li>более лаконичный код</li>
    </ul>
    <ul>Минусы:
      <li>труднее разобраться в коде</li>
    </ul>

    <h3>Структурная / номинативная</h3>
    <p><b>Структурная типизация:</b> определяет совместимость типов основываясь не на иерархии наследования или явной
      реализации интерфейсов, а на их описании. Компилятор считает типы совместимыми, если сопоставляемый тип имеет все
      признаки типа, с которым сопоставляется. Чтобы быть совместимым, сопоставляемый тип должен иметь те же ключи с
      теми же (идентичными или совместимыми) типами, что и тип, с которым происходит сопоставление</p>
    <p><b>Номинативная типизация:</b> устанавливает совместимость типов основываясь на идентификаторах типов (ссылках).
      При проверке на совместимость компилятор проверяет иерархию типов на признаки наследования и
      реализацию интерфейсов. То есть, тип B будет совместим с типом A только тогда, когда он является его предком
      (extends). Кроме того, тип B будет совместим с интерфейсом IA только в том случае, если он или один из его предков
      реализует его явно (implements)</p>
    <p>Как работает структурная типизация в Typescript:</p>
    <pre><code>
    class Car {
      id: number;
      numberOfWheels: number;
      move (x: number, y: number) {
          // некая реализация
      }
  }
    
    class Boat {
        id: number;
        move (x: number, y: number) {
            // некая реализация
        }
    }
    
    let car: Car = new Boat(); // здесь TypeScript выдаст ошибку, в Boat отсутствует свойство numberOfWheels
    let boat: Boat = new Car(); // а на этой строчке все в порядке - Класс Car содержит все свойства и методы класса Boat, поэтому Car может использоваться в качестве Boat
    </code></pre>


    <h2 id="js-ts-typing">Какие виды типизации используются в JavaScript и TypeScript?</h2>

    <p><b>JavaScript:</b> Динамическая | Слабая | Неявная</p>
    <p><b>TypeScript:</b> Статическая | Сильная | Явная | Структурная (???????????)</p>


    <h2 id="data-types">Как и для каких целей используются типы данных, приведенные ниже?</h2>
    <h3>Boolean</h3>
    <p></p>
    <h3>Number</h3>
    <p></p>
    <h3>String</h3>
    <p></p>
    <h3>Null and Undefined</h3>
    <p></p>
    <h3>Object and object</h3>
    <p></p>
    <h3>Array</h3>
    <p></p>
    <h3>Tuple</h3>
    <p></p>
    <h3>Enum</h3>
    <p>Enum — это конструкция, состоящая из набора именованных констант, именуемая списком перечисления и определяемая
      такими примитивными типами, как number и string. Enum объявляется с помощью ключевого слова enum</p>
    <h3>Any</h3>
    <p>Используетя, если тип конструкций может быть неизвестен. Примером этого может служить сервис, который работает с
      сервером посредством api. Полученные и сериализованные данные могут храниться как тип any прежде чем они будут и
      преобразованы к конкретному типу.</p>
    <p>Тип any является уникальным для TypeScript, в JavaScript подобного типа не существует. Any является базовым для
      всех остальных типов. Все типы в TypeScript являются его подтипами. Это означает, что он совместим в обе стороны с
      любым другим типом и с точки зрения системы типов является высшим типом (top type).</p>
    <h3>Void</h3>
    <p>Тип данных Void можно назвать полной противоположностью типа any, так как этот тип означает отсутствие
      конкретного типа. Основное предназначение типа Void — явно указывать на то, что у функции или метода отсутствует
      возвращаемое значение.</p>
    <h3>Never</h3>
    <p>Примитивный типа данных Never служит для указания того, что какие-либо операции никогда не будут выполнены.</p>
    <h3>Unknown</h3>
    <p>Тип Unknown является типобезопасным аналогом типа any и представлен в виде литерала unknown. Тип unknown
      позволяется использовать только в операциях равенства ===, ==, !== и != и в операциях с логическими операторами
      &&, || и !.</p>




    <h2 id="Union-intersection">Union и intersection типы</h2>
    <h3>Для чего нужны?</h3>
    <p>Позволяют скомбинировать существующие типы вместо того, чтобы создать их с нуля</p>
    <h3>Как использовать?</h3>
    <p> <b> Объединение (Union) </b>— это механизм, позволяющий создавать из множества существующих типов логическое
      условие, по которому данные могут принадлежать только к одному из указанных типов. Объединение указывается с
      помощью оператора прямой черты |, по обе стороны которой располагаются типы данных.</p>
    <pre><code>
        let v1: T1 | T2 | T3;
      </code></pre>
    <p>Переменной, которой был указан тип объединения A или B или C, может быть присвоено значение, принадлежащие к
      одному из трех типов.</p>

    <p> <b>Пересечение (Intersection)</b> — ещё один механизм TypeScript, который позволяет рассматривать множество
      типов
      данных как единое целое. Пересечение указывается с помощью оператора амперсанда & по обе стороны от которого
      указываются типы данных.</p>
    <pre><code>
        let v1: T1 & T2 & T3;
      </code></pre>
    <p>Переменной, которой был указан тип пересечение A и B и С должно быть присвоено значение принадлежащее к типам A и
      B и C одновременно. Другими словами значение должно обладать всеми обязательными признаками каждому типа
      определяющего пересечение.</p>
    <b> Пояснение человеческим языком <a
        href="https://ru.stackoverflow.com/questions/876192/%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%B2-typescript-%D0%BF%D0%B5%D1%80%D0%B5%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-%D1%82%D0%BE-%D1%87%D1%82%D0%BE-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-%D0%BE%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8-%D0%BC%D0%BD">Читать
        здесь >></a> и <a
        href="https://stackoverflow.com/questions/38855908/naming-of-typescripts-union-and-intersection-types">здесь</a></b>

    <h2 id="interfaces">Для чего предназначены интерфейсы?</h2>
    <p> <b>Interface</b> — это синтаксическая конструкция, предназначенная для описания открытой (public) части объекта,
      класса, функционального выражения без реализации (api), т.е. описания состояния и поведения (какие свойства и
      методы он содержит, какие типы они возвращают и т.д.).</p>
    <p>Интерфейс объявляется с помощью ключевого слова interface, после которого указывается идентификатор (имя), за
      которым следует заключенное в фигурные скобки тело содержащее описание.</p>
    <pre><code>
        interface Identifier {
          // тело интерфейса 
      }
      </code></pre>


    <h2 id="type-aliases">Что такое Type Aliases? Зачем нужны? Чем отличаются от интерфейсов?</h2>

    <p>Псевдоним типа объявляется при помощи ключевого слова type, после которого следует идентификатор (имя)
      псевдонима, а за ним идет оператор присваивания =, справа от которого находится тип, ассоциирующийся с
      псевдонимом. Например:
    </p>
    <pre><code>
    class Type {
      method(): void {
          type Alias = Type;
      }
  }
    type Alias = Type;
    </code></pre>
    <p>Разберем разницу между интерфейсом и типом в TS. С выходом новых версий TS отличия между ними очень сильно
      размываются и уже давно тип и интерфейс являются взаимозаменяемыми почти во всех случаях. Интерфейс и тип мы можем
      использовать для описания свойств объекта:</p>


    <pre><code>
  interface UserA {
    name: string;
    age: number
  }

  type UserB = {
    name: string;
    age: number
  }

const user1: UserA  = {
  name: 'Ivan',
  age: 20
}

const user2: UserB  = {
  name: 'Petr',
  age: 30
}

</code></pre>


    <p> В данном случае они будут полностью взаимозаменяемы. Разница только в синтаксисе. Интерфейс объявляется в
      синтаксисе похожем на класс, а тип - в синтаксисе похожем на объект.</p>
    <p>Также и тип и интерфейс можно использовать для описания поведения функции. Разницы никакой нет, сигнатура
      осталась той же:</p>


    <pre><code>
  interface SumA {
    (a: number, b: number): number
  }

  type SumB = (a: number, b: number) => number; 

  const sum1: SumA = (a, b) => a + b;
  const sum2: SumB = (a, b) => a + b;

</code></pre>
    <p> В старых версиях TS нельзя было наследоваться интерфейсом от типа, но в последних версиях это возможно (если это
      объектный тип (object type) или пересечение объектных типов со статически известными членами):</p>

    <pre><code>
    type B = {
    name: string;
    }

    interface A extends B {} // интерфейс наследуется от типа

    const B: A = {
    name: 'Lena';
    }
    </code></pre>


    <p>Как видим, в большинстве случаев интерфейсы и типы являются взаимозаменяемыми</p>
    <p>Различия:</p>
    <p><b>1) с помощью типа можно сделать alias для какого-то примитивного значения:</b></p>
    <pre><code>
  type UniqueID = string;
</code></pre>
    <p>Далее чтобы писать более понятные типы, его можно использовать в других интерфейсах для большего понимания, что
      происходит в системе:</p>
    <pre><code>
interface User {
  id: UniqueID
}
</code></pre>
    <p>Alias примитива можно сделать только с помощью типа. Но если это alias не для примитивного значения, а например
      для массива, то можно использовать и интерфейс</p>
    <pre><code>
  type NamesA = string[];
  interface NamesB { // Здесь определен интерфейс, который содержит сигнатуру массива. Эта сигнатура указывает, что объект, который реализует NamesB, может индексироваться с помощью чисел (объекта типа number). И, кроме того, данный объект должен хранить объекты типа string, то есть строки.
    [key]: number: string 
  }
</code></pre>

    <p><b>2) с помощью интерфейса невозможно описать тип кортежа (кортеж это массив, длина которого не изменяется)</b>
    </p>

    <pre><code>
  type State = [number, (a: number) => void]
  const tup = [123, (n) => {}]
  </code></pre>
    <p><b>3) мы можем создать тип, который будет частично имплементировать другой тип</b></p>

    <pre><code>
  type UserA = {
    name: string;
  }

  type UserB = {
    age: number
  }

  type C = A | B;

const obj1: C = { // ok
  name: 'S',
}
const obj2: C = { // ok
  age: 10,
}
const obj3: C = { // надо проверить, может ли объект содержатьоба свойства
  name: 'S',
  age: 10,
}
</code></pre>
    <p>Написать подобный интерфейс невозможно</p>

    <pre><code>
  interface D extends A | B {} // невалидный код
  interface D extends C {} // невалидный код, т.к. экстендиться от типа, который содержит внутри себя union, невозможно
  interface D extends A, B {} // ok, но тогда обязательными будут оба поля
</code></pre>
    <p><b>4) Типы, в отличие от интерфейсов, не могут быть объявлены несколько раз</b></p>
    <pre><code>
 type A = {
   age: number
 }

 type A = { // ошибка
  name: string
}

interface B = {
  age: number
}

interface B = { // ok, произошел automerge, расширение интерфейса. Теперь объект с интерфейсом B должен иметь два поля
 name: string
}
  
const obj: B = {
  age: 20,
  name: 'Masha'
}
</code></pre>

    <p><b>5) Псевдонимы типов нельзя использовать в таких операциях с типами времени выполнения как typeof и instanceof
        - ??????? ЧТО ЭТО ЗНАЧИТ?????</b></p>






    <h2 id="class-implements-extends">Может ли класс одновременно реализовывать набор интерфейсов и наследоваться от
      другого класса?</h2>
    <p>Может:</p>

    <pre><code>
        interface IAnimal {}
        interface IOviparous {} 
        
        class Bird implements IAnimal, IOviparous {} 
        
        interface IFlyable {}
        interface IPredatory {}
        
        class Eagle extends Bird implements IFlyable, IPredatory {} //надо проверить, может ли класс, наследующийся от другого класса, реализовывать более одного интерфейса (наверное может)
      </code></pre>
    <h2>От чего могут наследоваться интерфейсы? Какие накладывает ограничения наследование от класса?</h2>
    <p>Наследование интерфейсов осуществляется с помощью ключевого слова extends, после которого через запятую идет один
      или несколько идентификаторов расширяемых интерфейсов / типов / классов</p>
    <p> <b>От других интерфейсов</b> </p>
    <pre><code>
      interface IIdentifiable {}
      interface ILiving {}
      
      // интерфейсы IIdentifiable и ILiving вместе образуют логически связанную композицию, 
      // которую можно выделить в интерфейс IAnimal
      interface IAnimal extends IIdentifiable, ILiving {}
    </code></pre>

    <p><b>От типов</b></p>
    <p> В старых версиях TS нельзя было наследоваться интерфейсом от типа, но в последних версиях это возможно (если это
      объектный тип (object type) или пересечение объектных типов со статически известными членами):</p>

    <pre><code>
    type B = {
    name: string;
    }

    interface A extends B {} // интерфейс наследуется от типа

    const B: A = {
    name: 'Lena';
    }
    </code></pre>
    <pre><code>
  
    </code></pre>

    <p><b>От классов</b></p>
    <pre><code>
      class Animal {
        nickname: string;
        age: number;
    }
    
    interface IAnimal extends Animal {} //интерфейс наследуется от класса
    
    class Bird implements IAnimal {
        nickname:string;
        age: number;
    }
    
    let bird: IAnimal = new Bird();
    </code></pre>

    <p>Интерфейс, полученный путем расширения типа класса, может быть реализован только самим этим классом или его
      потомками, поскольку помимо публичных (public) также наследует закрытые (private) и защищенные (protected) члены.
    </p>
    <pre><code>
    class Animal {
      private uid: string;
      protected maxAge: number;
      public name: string;
  }
  
    interface IAnimal extends Animal {}
    
    class Bird extends Animal implements IAnimal { // Ok
        // private uid: string = ''; // Error, private
        protected maxAge: number = 100; // Ok, protected
        public name: string = 'bird'; // Ok,  public
    }
    
    class Fish implements IAnimal { // Error
        public name: string = 'fish';
    }
    
    let bird: IAnimal = new Bird(); // Ok
    let fish: IAnimal = new Fish(); // Error
    </code></pre>

    <h2>Каковы назначения модификаторов свойств классов?</h2>
    <p><b>Модификаторы доступа</b> — это ключевые слова, с помощью которых осуществляется управление сокрытием данных в
      классе. Простыми словами, модификаторы доступа задают уровень доступности членам класса ограничивая область их
      видимости.</p>
    <p>Чем меньше окружающему миру известно о внутреннем устройстве классов, тем меньше оно взаимодействует с ним.
      Взаимодействия программы с объектом называют сопряжением (coupling), уровень которого варьируется от сильного до
      слабого. Слабое сопряжение (loose coupling) является признаком качественной архитектуры программы. Этот факт
      подталкивает скрывать как можно больше информации при проектировании программы.</p>
    <p><b>Модификаторы доступа и конструкторы класса</b></p>
    <p>Конструктор, который не отмечен ни одним модификатором доступа эквивалентен конструктору, помеченному как public.
      <i>Если класс состоит только из статических свойств и методов, как например класс Math, то его конструктор более
        разумно пометить как приватный и, тем самым, запретить создание его экземпляров. Кроме того, класс, у которого
        конструктор объявлен с модификатором доступа private, нельзя расширять (extends).</i>
    </p>
    <p>Класс, в котором конструктор объявлен с модификатором доступа <b>protected</b>, как и в случае с модификатором
      доступа private, также не позволит создать свой экземпляр, но открыт для расширения (extends).</p>
    <p>Тем не менее есть один нюанс. Не получится создать экземпляр подкласса, если он не переопределил конструктор
      суперкласса.</p>

    <p><b>Public.</b> Члены, помеченные ключевым словом public (или не помеченные никаким - в этом случае они считаются
      public), доступны в определяющих их классах, их потомках, а также к ним можно обращаться через экземпляр или, в
      случае статических членов, через ссылку на класс.</p>
    <p><b>Private </b>является полной противоположностью модификатору доступа public. Члены, помеченные с помощью
      ключевого слова private, доступны только контексту класса, в котором они определены.</p>
    <p><b>Protected.</b> Члены, которым установлен модификатор доступа protected, доступны только контексту класса, в
      котором они определенны, а также всем его потомкам. Попытка обратится к членам, помеченным как protected снаружи,
      приведет к возникновению ошибки. Как правило, при современной разработке упор делается только на два вида
      модификаторов доступа - public и private. Но, в редких случаях, по сценарию может возникнуть необходимость
      обращаться к членам своего суперкласса в подклассах, которые при этом, должны быть скрыты от окружающего мира. В
      таких случаях члены помечают как protected.</p>
    <h3>В чем отличие private от #?</h3>
    <p>Влияние модификаторов доступа public, protected и private ограничивается TypeScript и после компиляции от них не
      остается ни следа. В скомпилированном коде нет никакой разницы между членами, к которым были применены те или иные
      модификаторы доступа</p>
    <p>Для того, что бы поля класса оставались закрытыми после компиляции в JavaScript, необходимо прибегнуть к
      модификатору, определенному спецификацией ECMAScript # который указывается в качестве префикса их идентификаторов
      (имен) #identifier.</p>
    <p>Доступ к защищенному полю класса ограничивается областью видимости класса в котором оно объявлено, а при
      обращении к нему необходимо также указывать символ решетки.</p>
    <p>Поскольку доступ ограничивается областью видимости класса, классы-потомки не могут обращаться к защищенным полям
      своих предков.</p>
    <p>Данный модификатор может быть применён не только ко всем членам экземпляра класса предусмотренного спецификацией
      ECMAScript, но и к членам самого класса (static). <i>Модификация статических полей, при активном флаге возможна
        только при активации флаге --useDefineForClassFields.</i></p>
    <p>В отличие от модификатора доступа private, этот механизм не может быть применён к методам и аксессорам класса,
      но, так как за его появлением стоит спецификация ECMAScript, он продолжает действовать в скомпилированной
      программе. Именно поэтому, в отличие от сценария с модификатором доступа private, потомки могут без страха
      нарушить ожидаемый ход выполнения программы и объявлять защищенные поля, чьи идентификаторы идентичны объявлениям
      в их супер-классах.</p>
    <p>Нюансы:</p>
    <p>1) Закрытые поля нельзя объявлять непосредственно в конструкторе.</p>
    <p>2) Код, содержащий закрытые поля класса, может быть скомпилирован исключительно в версии es6 и выше.</p>
    <h2>В чем отличие абстрактных классов от обычных классов и интерфейсов?</h2>
    <p>Абстрактные классы могут содержать абстрактные члены, принадлежность к которым указывается с помощью ключевого
      слова abstract. Ключевое слово abstract можно применить к полям, свойствам (аксессоры) и методам абстрактного
      класса; <b>абстрактные поля</b> могут иметь значение ( но в этом случае обратится к нему могут только абстрактные
      классы в иерархии наследования); <b>абстрактные свойства и методы</b> не должны иметь реализацию. Кроме
      абстрактных членов, абстрактные классы могут содержать обычные члены, обращение к которым ничем не отличается от
      членов, объявленных в обычных классах. <i>Как правило, абстрактные классы реализуют только ту логику, которая не
        будет ни при каких обстоятельствах противоречить логике своих подклассов.</i> </p>
    <p><b>Отличия от обычных классов:</b></p>
    <p>1) Нельзя создать экземпляр абстрактного класса.</p>
    <p>2) Абстрактный класс, расширяющий другой абстрактный класс, не обязан переопределять все абстрактные члены своего
      суперкласса. В отличие от абстрактных классов, обычные классы, расширяющие абстрактные классы, обязаны
      переопределить все абстрактные поля, свойства и методы, находящиеся в иерархической цепочке, если они не были
      реализованы предками ранее.</p>

    <p><b>Отличия от интерфейсов:</b></p>
    <p><i>Интерфейсы</i> предназначены для описания публичного api, которое служит для сопряжения с программой. Кроме
      того, они не должны, а в TypeScript и не могут, реализовывать бизнес логику той части, которую представляют.
      <i>Абстрактные классы,</i> при необходимости, должны реализовывать интерфейсы в той же степени и для тех же целей,
      что и обычные классы. Их однозначно нужно использовать в качестве базового типа тогда, когда множество логически
      связанных классов имеет общую для всех логику, использование которой в чистом виде не имеет смысла. Другими
      словами, если логика размещенная в классе не может или не должна выполнятся отдельно от потомков, то необходимо
      запретить создание экземпляров подобных классов.
    </p>
    <b><a href="https://typescript-definitive-guide.ru/book/chapters/Abstraktnye_klassy_(abstract_classes)/">Подробнее
        про абстрактные классы и интерфейсы</a></b>




    <h3 id="index-types">Для чего используются Index types?</h3>
    <p>Сигнатура индекса в объявлении интерфейса позволяет указать любое количество свойств для разных объектов, которые
      будут созданы в соответствии с данным интерфейсом.</p>
    <p>Индексная сигнатура (index signature) состоит из двух частей. В первой части расположен имеющий собственную
      аннотацию типа идентификатор привязки (binding identifier) заключенный в квадратные скобки []. Во второй части
      расположена аннотация типа (type annotation) представляющего значение ассоциируемое с динамическим ключом.</p>

    <p>В этом примере я использовал сигнатуру индекса для добавления информации о разных поселениях вокруг озер.
      Поскольку у каждого озера будут свои поселения, использование дополнительных объектов не было бы хорошей идеей.
    </p>

    <pre><code>
      interface Lakes {
           name: string,
           area: number,
           length: number,
           depth: number,
           isFreshwater: boolean,
           countries: string[],
           frozen?: string[],
           [extraProp: string]: any
       }
        
       let fourthLake: Lakes = {
           name: 'Tanganyika',
           depth: 1470,
           length: 676,
           area: 32600,
           isFreshwater: true,
           countries: ['Burundi', 'Tanzania', 'Zambia', 'Congo'],
           kigoma:'Tanzania', // индексированное поле
           kalemie: 'Congo',// индексированное поле
           bujumbura: 'Burundi'// индексированное поле
       }
    </code></pre>
    <h3>Для чего нужен оператор keyof?</h3>
    <p>В TypeScript существует возможность выводить все публичные, не статические,
      принадлежащие типу ключи и на их основе создавать литеральный объединенный тип ( U
      nion ). Для получения ключей нужно указать оператор keyof , после которого
      указывается тип, чьи ключи будут объединены в тип объединение keyof Type .</p>


    <pre><code>
  
      type AliasType = { f1: number, f2: string };
      interface IInterfaceType {
      f1: number;
      f2: string;
      }
      class ClassType {
      f1: number;
      f2: string;
      }
      let v1: keyof AliasType; // v1: "f1" | "f2" - тип из ключей типа
      let v2: keyof IInterfaceType; // v2: "f1" | "f2" - тип из ключей интерфейса
      let v3: keyof ClassType; // v3: "f1" | "f2"  - тип из ключей класса
      let v4: keyof number; // v4: "toString" | "toFixed" | "toExponential" | "toPrecision" | "valueOf" | "toLocaleString" - тип из ключей объекта

    </code></pre>

    <h2 id="generics">Для чего нужны generics</h2>
    <p>Для того, чтобы разобраться в дженериках, давайте вспомним, как работают обычные типы в тайпскрипт.
      Простые типы, создаваемые в TS, работают по принципу констант или монолитов. Т.е. если у меня есть несколько
      интерфейсов,
      например User и Message, то я их использую только для сообщений и для пользователей соответственно.
      Каждый из этих интерфейсов может быть наделен какими-то свойствами:</p>


    <pre><code>
  interface User {
    name: string;
    age: number
  }

  interface Message {
  id: number;
  text: string
  }
        </code></pre>
    <p>В современных front-end приложениях мы все эти данные загружаем по api, т.е. если нам нужно загрузить
      пользователя,
      то нам нужны еще
      дополнительные свойства, например MessageState:</p>
    <pre><code>
  interface UserState {
    loading: boolean;
    error: Error | null;
    data: User
  }

  interface MessageState {
    loading: boolean;
    error: Error | null;
    data: Message
  }
</code></pre>
    <p>Множество конструкций такого типа только усложняет наш код, так как отличаются сейчас стейты только тем, что
      UserState использует
      тип User, а MessageState - тип Message.
      Нежелание тратить усилия на описание монолитных типов такого плана послужило созданию дженериков.
      Дженерик в TS - это параметризованный тип, позволяющий объявлять параметры типа, являющиеся временной заменой
      конкретных монолитных типов,
      определение которых будет выполнено в момент использования.</p>
    <p>Дженерики в TS объявляются при помощи пары угловых скобок &lt&gt, в которые через запятую записываются типы:</p>

    <pre><code>
  interface State&ltT, U, V, K&gt{} // определили интерфейс State, который использует четыре дженерик типа
  </code></pre>
    <p>Количество типов не ограничено.</p>
    <p>Также дженерики можно использовать не только в интерфейсах, но и в типах, классах, функциях:</p>
    <pre><code>
  type State2&ltT, U, V, K&gt = {} // в типе

  class State3 &ltT&gt {} // в классе
  
  function state4 &ltT&gt (){} // в функции
  </code></pre>
    <p>Ведут себя дженерики везде одинаково, т.е. правила их сипользования идентичны, поэтому изучить их придется один
      раз, а использовать повсеместно.</p>
    <p>Для того, чтобы разобраться, как работают дженерики, возьмем классический пример из официальной документации TS:
    </p>
    <pre><code>
  function identity(arg){
    return arg;
  }

  const s: string = 'Hello';
  const n: number = 10;

  const r1 = identity(s); // r1 имеет тип any, хотя s имеет тип string
  const r2 = identity(n); // r2 имеет тип any, хотя n имеет тип number

</code></pre>

    <p>Т.к. мы передаем аргумент и аргумент того же типа ждем в ответ, и т.к. наша функция умеет работать с любыми
      типами,
      здесь как раз нам подойдут дженерики.
      Т.е. мы можем сказать, что функция identity работает с типом T, аргумент, который прилетает в функцию, будут типа
      T,
      при этом принадлежность этого типа Т устанавливается в момент передачи аргумента.
      Т.е. если передаем сюда S (строку), то Т будет тоже строкой и вернется значение тоже типа Т (строка):</p>

    <pre><code>
  function identity &ltT&gt (arg: T): Т {
    return arg;
  }

  const s: string = 'Hello';
  const n: number = 10;

  const r1 = identity(s); // r1 имеет тип string
  const r2 = identity(n); // r2 имеет тип number


</code></pre>
    <p> При использовании дженериков тайпскрипт распознает типы переменных на лету, тем самым позволяя писать более
      универсальный код</p>
    <pre><code>
  const user: User = {
    name: 'Max',
    age: 20
  }

  const r3 = identity(user); // r3 имеет тип User
</code></pre>
    <p> Давайте вернемся к нашим типам User и Message и создадим для них дженерик тип State:</p>

    <pre><code>
  interface State&ltT&gt { // указываем, что это интерфейс-дженерик
    loading: boolean;
    error: Error | null;
    data: T
  }

  type UserState = State&ltUser&gt
  type MessageState = State&ltMessage&gt

  const messageState: MessageState = {
    loading: false,
    error: null,
    data: {
      id: 1,
      text: 'Text'
    }
  }
</code></pre>
    <p>Если дженерик указывается в качестве типа данных, то он обязан содержать аннотацию обобщения, т.е. &ltUser&gt или
      &ltMessage&gt.
      State сам по себе существовать не может, т.к. он ожидает на вход дженерик. Т.е. рассмотреть дженерик можно как
      функцию, которую мывызываем
      с определенным типом и она возвращает новую структуру с использованием пееданного типа.</p>

    <p> А сейчас типизируем что-то чуть более сложное. Создадим функцию, которая будет возвращать случайный элемент
      массива генерируем случайный индекс и берем элемент по этому индексу:</p>
    <pre><code>
    function getRandomElement (items){
      const randomIndex = Math.floor(Math.random() * items.length);
      return items[randomIndex];
    }

    const el1 = getRandomElement([1,2,3,4,5]); // el1 имеет тип any
  </code></pre>
    <p>Используем дженерики. Переменная items это массив типов Т, возвращает функция тоже тип Т:</p>


    <pre><code>
    function getRandomElement &ltT&gt (items: T[]): T {
      const randomIndex = Math.floor(Math.random() * items.length);
      return items[randomIndex];
    }

    const el1 = getRandomElement([1,2,3,4,5]); // el1 имеет тип number
    const el2 = getRandomElement(['a', 'b', 'c', 'd', 'e',]); // el1 имеет тип string
    const el2 = getRandomElement(['a', 'b', 'c', 'd', 1,]); // el1 имеет тип string|number 
  </code></pre>
    <p>Еще один пример с объектами</p>

    <pre><code>
  function merge (o1, 02){
      return {...o1, ...o2};
  }

  const r1 = merge({a: 1}, {b: 2}); // r1 имеет тип any, т.к. никакие типы не указаны 
  </code></pre>
    <p>Если мы хотим, чтобы TS распознавал типы налету, мы используем дженерик</p>

    <pre><code>
   
    function merge &ltU, V&gt (o1 &ltU&gt, 02 &ltV&gt) U & V{ //т.к. TS знает, что он возвращает объединение U и V ...
        return {...o1, ...o2};
    }
  
    const r1 = merge({a: 1}, {b: 2}); //... он указывает, что тип r1 - это оъединение {a: number} & {b: number}
    </code></pre>
    <p>В TS существует множество встроенных дженериков. Самый популярный из них это <b>дженерик Promise</b> .</p>
    <p> Функция fakeRequest всегда вернет промис, т.к. асинхронные функции всегда возвращают промис:</p>



    <pre><code>
  async function fakeRequest(){
    return 2
  }
</code></pre>
    <p>Вызов fakeRequest без await. Будет ошибка <b>"Type '() => Promise&ltnumber&gt' is not assignable to type
        'number'"</b> .
      Это значит, что нельзя записать число в промис, т.к. fakeRequest всегда вернет промис</p>
    <pre><code>
  const b:number = fakeRequest() 
</code></pre>
    <p>Поэтому надо использовать дженерик Promise</p>


    <pre><code>
  const b: Promise&ltnumber&gt = fakeRequest(); //Здесь, т.к. я использую дженерик как тип, я должен явно указать, какой тип будет использоваться
   </code></pre>
    <p>Другой пример</p>
    <pre><code>
   type Names = string[]; // массив строк
    type Names = Array&ltstring&gt; // то же самое, но используя дженерик
    </code></pre>

    <p> Также существует <b>дженерик для создания объекта</b> . Например мы хотим создать объект, у которого ключи будут
      строками, а значения - числами</p>



    <pre><code>
  type Obj = {
    [key: string]: number
  }
/*чтобы не делать запись, как запись выше, можно использовать встроенный дженерик*/
type Obj =  Record&ltstring, number&gt; // ключи - строки, значения - числа
</code></pre>
    <p>Помимо того, что в дженериках параметры можно указывать в качестве конкретного типа, они также могут расширять
      другие типы,
      в т.ч. и другие параметры типа. Такой механизм требуется для ограничения наборов обязательных признаков для
      выполнения операций</p>

    <p>Пример. Функция len, которая принимает массивоподобный объект и возвращает его длину:</p>
    <pre><code>
 function len(collection){
  return collection.length;
}
</code></pre>
    <p>можно получить длину у строки, у массива, но у числа получить ее не могу:</p>

    <pre><code>
const r1 = len('Hello'); // ok
const r1 = len([1, 2, 3]); // ok
const r1 = len(1); // error
</code></pre>
    <p>С помощью дженерика я могу указать, что моя коллекция будет ограничена (extends) только теми структурами
      данных, у которых есть свойство
      length и оно имеет тип number</p>

    <pre><code>
  function len &ltT extends {length: number}&gt (collection){
    return collection.length;
  }
  
</code></pre>
    <p>Более юзабельный кейс - у нас есть класс DataCollection и он умеет работать с разными коллекциями.
      У него есть конструктор, который создает публичное свойство data, для начала опишем его с any;
      И у него есть метод search, который выполняет поиск по ID в массиве data</p>


    <pre><code>
  class DataCollection {
    constructor(public data: any[]){}

    search (id: string) {
      return this.data.find(d => d.id === id);
    }
  }

  const users = new DataCollection ([{
    id: '1'
  }]); // users имеет тип DataCollection

  const messages = new DataCollection ([{
    text: 'Message' // даже если не будет свойства id, то TS не поругается, т.к. он не знает, что мы работаем с ID, хотя код работать не будет
    
  }])

  messages.search(1); // вернется null

</code></pre>
    <p>Поэтому для того, чтобы уметь работать с разными структурами данных, мы можем использовать дженерик. Т.к. users и
      messages имеют разные типы, но из общего можно определить id. Поэтому можно сказать, что
      DataCollection работает с любой структурой данных, у которой есть свойтсво id и оно string</p>

    <pre><code>

  class DataCollection &ltT extends {id: string}&gt{
    constructor(public data: T[]){}

    search (id: string) {
      return this.data.find(d => d.id === id); // ошибка - 'Property id does not exist on type 'T''
    }
  }

type User = {
  id: string,
  name: string
}

type Message = {
  id: string,
  text: string
}

  const users = new DataCollection ([{
    id: '1'
  }]); // users имеет тип DataCollection

  const messages = new DataCollection ([{
    text: 'Message' // теперь здесь будет ошибка, что это невалидный объект, т.е. нужно добавить свойство id
  }])

  /*добавляем id, также мы можем определить у этого объекта тип */

const message: Message = {
  text: 'Message', 
  id: '2'
}
const messages = new DataCollection ([message]); // ok

const searchableMessage = messages.search(1); // searchableMessage имеет тип Message|undefined

/*точно такая же ситуация с users*/

const user: User = {
  text: 'Message', 
  id: '2'
}
const users = new DataCollection ([users]); // ok
const searchableUsers = users.search(1); // searchableUsers имеет тип User|undefined
</code></pre>
    <p>Еще один пример - нам нужно просто получать свойство из объекта.
      Создадим function, назовем ее getValue.</p>

    <pre><code>
  function getValue(obj, prop){
    return obj[prop];
  }


  const r1 = getValue({
    name: 'Max'
  }, age); // свойства age нет, но TS просто указывает на то, что вернется any и сам разбирайся, что с ним делать 
</code></pre>
    <p>Но используя дженерик мы можем определить тип объекта, который нам приходит, и указать, что он должен быть только
      объект,
      т.е. ничего другого туда передавать нельзя</p>

    <pre><code>
function getValue &ltT extends object&gt(obj: Т, prop){
  return obj[prop];
}
</code></pre>
    <p>если передать первым параметром строку, то TS будет ругаться, говорить, что нельзя передать строку, т.к. нам
      нужен object
      т.е. мы c помощью extends ограничиваем набор типов, которые могут быть переданы в эту функцию</p>

    <pre><code>
const r1 = getValue('$', age); 
</code></pre>
    <p>для второго параметра укажем, что второй аргумент будет иметь тип U, а U будет ограничен ключами Т.
      extends в этом случае знает, что в переменную Т может быть записан только то, что может быть записано в объект, а
      в
      U
      может быть записано только то, что является ключом Т, т.е. нашего объекта</p>

    <pre><code>
function getValue &ltT extends object, U extends keyof T&gt(obj: Т, prop: U){
  return obj[prop];
}
  const r1 = getValue({
  name: 'Max'
}, name);  // вторым аргументом можем указать только name, т.к. в объекте только один ключ name.
</code></pre>
    <p>Если же в объекте будет больше ключей, то можем указать любой из них</p>

    <pre><code>
  const r1 = getValue({
  name: 'Max',
  age: 20
}, age);  // ok
</code></pre>
    <p>Теперь создадим функцию, которая возвращает ключ, а не свойство. Т.е. все то же самое, тоже передаем объект,
      но теперь мы спрашиваем
      value и возвращаем ключ</p>

    <pre><code>
/*obj - объект, value - не ключ объекта, как предыдущем случае, а его value; 
возвращать будем ключ или null*/

  function getKey&ltT extends object, U extends keyof T&gt (obj: T, value: T[U]): U|null {

/*Object.keys прокидывает строку, но нам нужно сказать, что массив U*/
  const key = obj.keys(obj) as Array&ltU&gt.find(k => obj[k]===value) // перебираем ключи и находим то значение, кот. совпадает с переданным
  }
  return key || null ;


  const key = getKey ({ // key имеет тип "name"|null
  name: 'Max'
  }, 'Max')

/*другой вариант записи*/
  function getKey&ltT extends object&gt (obj: T, value: T[keyof T]): keyof T|null {

/*Object.keys прокидывает строку, но нам нужно сказать, что массив U*/
  const key = obj.keys(obj) as Array&ltkeyof T&gt.find(k => obj[k]===value) // перебираем ключи и находим то значение, кот. совпадает с переданным
  }
  return key || null ;
</code></pre>

    <p>Еще один пример </p>
    <p> Нужно создать функцию, которая будет называться patchField, она будет принимать:</p>
    <p>1) объект,</p>
    <p>2) свойство объекта, которое нужно пропатчить (поменять).</p>
    <p>3) значение, на которое нужно поменять</p>
    <p>При этом patchField должна быть функцией безопасной, т.е. если тип данных значения объекта, из которго берется
      пропатчиваемое свойство
      - это number, то его можно поменять только на number, если string - то толькл на string и т.д.</p>

    <pre><code>

/*У нас будет три дженерика*/


  patchField&lt
    T extends object, // принимаем объекты первым аргументом 
    U extends keyof T, // принимаем ключи вторым аргументом 
    V extends T[U]// принимаем тип значения, которое мы хоти поменять, третьим аргументом. Т.е. нашли объект, нашли его ключ и взяли его значение
    &gt(obj: T, field: U, value: V)
</code></pre>
    <p>Также TS позволяет указывать для параметров типа значения по умолчанию</p>


    <pre><code>
  
function format&ltT&gt(s?: T): T|undefined{
  return s;
  }

  const s1 = format(); // s1 имеет тип unknown

  /*задаем дефолтное значение*/

function format&ltT=string&gt(s?: T): T|undefined{
  return s;
  }

</code></pre>
    <p>Пример для закрепления, который использует все возможности дженериков.
      Создадим тип FunctionalComponent, который будет аналогом реакт FC</p>
    <p>тип FunctionalComponent, который будет принимать дженерик, и в реакте каждый компонент у нас имеет свойство
      children.
      Поэтому мы укажем, что это будет object, по дефолту он тоже будет оъектом, если он не передан.
      Это будет функция (т.к. все компоненты в реакте это функции), которая принимает пропсы типа Т и добавляет к ним
      children, который будет any и возвращает any</p>

    <pre><code>
  type FunctionalComponent&ltT extends object = object&gt = (props: T & children: any) => any;

  /*Теперь мы можем создать компонент типа FunctionalComponent, он будет принимать name типа string и age типа number*/

  const component: FunctionalComponent&lt{name: string, age: number}&gt = ({
    /*здесь я могу достать age, name, children, т.к. этот дженерик длбавил к объекту типа {name: string, age: number }  - children: any */
    age,
    name,
    children
  }) => {
  }

</code></pre>

    <p> <i>Обобщение (Generics)</i> — это параметризированный тип позволяющий объявлять параметры типа, являющиеся
      временной заменой конкретных типов, конкретизация которых будет выполнена в момент создания экземпляра.</p>
    <p>Принадлежность параметра типа к конкретному типу данных устанавливается в момент передачи аргументов типа. При
      этом конкретные типы данных указываются в паре угловых скобок, а количество конкретных типов должно
      соответствовать количеству обязательных параметров типа.</p>
    <h3>Какие есть встроенные обобщенные интерфейсы (built-in generic types)?</h3>

    <h3>Как ограничить возможные значения переменной типа?</h3>
    <p>Можно сделать дженерик подтипом другого типа ([переменная] extends [другой тип])</p>
    <p>&ltUserInfo extends {salary: number}&gt - значит в типе, который мы подставим в переменную UserInfo обязательно
      должно быть числовое поле salary
      и могут быть еще какие-то другие поля
    </p>


    <p>когда значения внутри обобщенного типа должны обладать ограниченным набором признаков, применяется
      расширение нашим типом другого типа или другого параметра типа. Используем ключевое слово <b>extends</b>
    </p>
    <pre><code>
        &ltT extends object, U extends keyof T&gt
      </code></pre>

    <h3>Как ограничить возможные значения переменной типа значениями другой переменной типа?</h3>

    <p>когда параметр типа расширяет другой тип, в
      качестве аргумента типа можно будет передать только совместимый с ним тип.</p>
    class T1 <T extends T2=T3> {}
      <p>В момент, когда тип T расширяет другой тип, он получает признаки этого типа. Именно
        поэтому для параметра типа, расширяющего другой тип, в качестве типа по умолчанию
        можно указывать только совместимый с ним тип.</p>
      <h3>Можно ли для переменной типа указать значение по умолчанию?</h3>
      <p>Можно</p>
      <pre><code>
        function format&ltT=string&gt(s?: T): T|undefined{
          return s;
          }
      </code></pre>
      <p>Параметры, которым заданы значения по умолчанию, являются необязательными параметрами. Необязательные параметры
        типа должны быть перечислены строго после обязательных. Если параметр типа указывается в качестве типа по
        умолчанию, то ему самому должно быть задано значение по умолчанию, либо он должен расширять другой тип.</p>

      <h3>Исправьте типизацию функции filterBy таким образом, чтобы она:</h3>
      <p>a. первым аргументом принимала массив любых объектов;</p>
      <p>b. вторым – имя поля, по которому производится фильтрация;</p>
      <p>c. третьим – значение, которое должно содержать поле;</p>
      <p>d. возвращала тип первого аргумента (исходного массива).</p>

      <pre><code>
          // исходная функция
          function filterBy(input: Object[], propName: string, propValue: any): Object[] {
            return input.filter(item => item[propName] === propValue);
          }
          // что должно получиться
          interface IEmployee {
            name: string;
            age: number;
            position: 'Programmer' | 'Accountant' | 'Designer';
          }
        
          const employees: IEmployee[] = [
            { name: 'Michael', age: 20, position: 'Programmer' },
            { name: 'Jordan', age: 25, position: 'Designer' },
            { name: 'Steve', age: 34, position: 'Accountant' },
            { name: 'Tom', age: 19, position: 'Programmer' },
            { name: 'Bob', age: 43, position: 'Programmer' },
            { name: 'Michael', age: 19, position: 'Programmer' },
            { name: 'Bob', age: 27, position: 'Designer' },
          ];
        
        filterBy(employees, 'position', 'Programmer'); // вернёт IEmployee[]
        filterBy(employees, 'surname', 'Cook'); // ошибка, тип IEmployee не содержит поле 'surname'
        filterBy(employees, 'position', 'Tester'); // ошибка, поле 'position' не может содержать значение 'Tester',
        </code></pre>
      <p><b>Решение:</b></p>

      <pre><code>
  function filterBy<O extends object, U extends keyof O>
    (input: O[], propName: U, propValue: O[U]): O[] {
    return input.filter((item) => item[propName] === propValue);
  }
</code></pre>
      <p>Не понятно, почему не работают вот эти варианты</p>
      <pre><code>
  //1
  function filterBy<T extends Array&ltO&gt, O extends object, U extends keyof O>
    (input: T, propName: U, propValue: O[U]): O[] {
    return input.filter((item) => item[propName] === propValue);
  }

  //2
  function filterBy<O extends Record&ltstring, unknown&gt, U extends keyof O>
    (input: O[], propName: U, propValue: O[U]): O[] {
    return input.filter((item) => item[propName] === propValue);
  }
</code></pre>
      <h3>Типизируйте класс List так, чтобы:</h3>

      <p>Конструктор класса принимал массив объектов с обязательным полем id;</p>
      <p>Метод addItem позволял добавить только объект с типом аргумента конструктора;</p>
      <p>Метод getList возвращал массив объектов с типом аргумента конструктора;</p>

      <pre><code>
        // Исходный класс

        class List {
          private list;
      
          constructor(list) {
            this.list = list;
          }
      
          addItem(item) {
            this.list.push(item);
          }
      
          getList() {
            return this.list;
          }
        }
        // Что должно получиться
      
        interface IGuest {
          login: string;
          password: string;
        }
      
        const guests: IGuest[] = [
          {
            login: 'guest',
            password: '123',
          }, 
          {
            login: 'user',
            password: '123',
          }
        ];
      
        const guestsList = new List&ltIGuest&gt(guests); // ошибка, в типе IGuest отсутствует поле id
      
        interface IUser {
          id: number;
          login: string;
          password: string;
        }
      
        const users: IUser[] = [
          {
            id: 1,
            login: 'guest',
            password: '123',
          }, 
          {
            id: 2,
            login: 'user',
            password: '123',
          }, 
          {
            id: 3,
            login: 'author',
            password: '123',
          }
        ];
      
        const usersList = new List&ltIUser&gt(users); // ok
      
        usersList.addItem({
          login: 'guest',
          password: '123',
        }); // ошибка, отсутствует поле id
      
        usersList.addItem({
          id: 3,
          login: 'admin',
        }); // ошибка, отсутствует поле password
      
        usersList.addItem({
          id: 5,
          login: 'guest',
          password: '123',
        }); // ok
      
        const usersArray = usersList.getList(); // IUser[];
      </code></pre>

      <p><b>Решение:</b></p>

      <pre><code>
        class List&ltT extends {id: unknown}&gt {
          private list;
        
          constructor(list: T[]) {
            this.list = list;
          }
        
          addItem(item: T) {
            this.list.push(item);
          }
        
          getList() {
            return this.list;
          }
        }
      </code></pre>

  </main>

</body>

</html>