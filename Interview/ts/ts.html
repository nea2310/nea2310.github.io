<!doctype html>
<html lang="ru">

<head>
  <meta charset="UTF-8">
  <script defer src="./main.js"></script>
  <link rel="stylesheet" href="./ts.css">
</head>

<body style="padding: 10px; border: 1px solid rgb(204, 199, 199); box-shadow: 0 0 10px 10px rgb(204, 199, 199);">
  <main style="margin: 0 auto; max-width: 2400px; width: 100%;">
    <p>
      Содержание
    <ul>
      <li>
        <a href="#what-is-ts">Что такое TypeScript? Для чего он нужен и какие проблемы решает?</a>
      </li>
      <li>
        <a href="#typing">Рассказать про следующие виды типизации, их особенности, плюсы и минусы</a>
      </li>
      <li>
        <a href="#js-ts-typing">Какие виды типизации используются в JavaScript и TypeScript?</a>
      </li>
      <li>
        <a href="#data-types">Как и для каких целей используются типы данных, приведенные ниже?</a>
      </li>
      <li>
        <a href="#Union-intersection">Union и intersection типы</a>
      </li>

    </ul>
    </p>
    <h1 id="ts">TS</h1>
    <h2 id="what-is-ts">Что такое TypeScript? Для чего он нужен и какие проблемы решает?</h2>
    <p>TypeScript — это язык программирования со статической типизацией, позиционирующий себя как язык, расширяющий
      возможности JavaScript.</p>
    <ul>Какие проблемы решает:

      <li>Выявление ошибок на этапе компиляции, а не на этапе выполнения</li>
      <li>За счет системы типов разработчики получают такие возможности, как подсказки и переходы по коду, которые
        значительно ускоряют процесс разработки</li>
      <li>Система типов в значительной степени избавляет разработчиков от комментирования кода, которое отнимает
        значительное время</li>
      <li>Система типов помогает раньше выявлять проблемы архитектуры, исправление которых обходятся дешевле на ранних
        этапах</li>
    </ul>
    <h2 id="typing">Рассказать про следующие виды типизации, их особенности, плюсы и минусы</h2>
    <h3>Слабая / сильная</h3>
    <p><b>Сильная типизация:</b> НЕ разрешает выполнение выражений с несовместимыми типами и не выполняют неявное
      преобразование типов в ситуациях, когда нужно выполнять преобразование явно.</p>
    <ul>Плюсы:
      <li>при операциях способных привести к потере или порче значения возникает ошибка. Благодаря этому сильно
        типизированные языки в меньшей степени подвержены багам.</li>
    </ul>
    <p><b>Слабая типизация:</b> разрешают выполнение выражений с любыми типами и самостоятельно выполняют неявное
      преобразование</p>
    <ul>Минусы:
      <li>Из-за того, что в языках со слабой типизацией допускаются неявные преобразования существует высокая
        вероятность возникновения трудно выявляемых багов. Причиной появления подобных багов является отсутствие
        возникновения ошибок в некоторых операциях неявного преобразования. Программа получает данные ожидаемого типа,
        но непредсказуемого значения</li>
    </ul>
    <h3>Статическая / динамическая</h3>
    <p><b>Статическая типизация:</b> контроль типов происходит на этапе компиляции. </p>
    <p>Особенности. До того момента, как программа будет запущена, компилятор осуществляет проверку совместимости типов,
      участвующих в различных операциях. Все конструкции, нуждающиеся в аннотации типа,
      связываются с типом данных при объявлении. При этом связь с типом данных в дальнейшем не может быть изменена</p>
    <ul>Плюсы:
      <li>За счет того, что большая часть проверок происходит на этапе компиляции, программа обладает большей
        производительностью из-за отсутствия проверок во время выполнения</li>
      <li>Языки со статической проверкой типов значительно повышают семантическую привлекательность кода делая его более
        читабельным</li>
      <li>Благодаря статическому контролю типов, редактор кода способен на основе синтаксического анализа выводить
        вспомогательную информацию, ускоряющую разработку</li>
    </ul>
    <p><b>Динамическая типизация:</b> контроль типов происходит на этапе выполнения программы. </p>
    <p>Особенности: конструкция нуждающаяся в аннотации типа, связывается с типом данных на этапе выполнения программы в
      момент присвоения значения. При этом связь с типом данных может быть изменена. Тип данных может быть определен
      только на основании вычисленного результата выражения. При этом операция присвоения значения может изменить тип
      данных сущности с которым она была связана ранее. Динамический контроль типов проверяет операнды на совместимость
      типов и совместимость с оператором в каждой отдельной операции. </p>
    <ul>Плюсы:</ul>
    <ul>Минусы:
      <li>Проверка типов данных во время выполнения программы отрицательно сказывается на её производительности. Поэтому
        языки с динамическим контролем типов проигрывают в производительности языкам со статическим контролем типов у
        которых совместимость проверяется на этапе компиляции.</li>
      <li>По причине выявления несовместимости типов только во время выполнения программы ошибки выявляются менее
        эффективно. Программа не узнает о скрывающейся в ней ошибке, пока не дойдет очередь выполнения проблемного
        участка кода.</li>
      <li>Редакторы кода, даже современные, испытывают трудности при синтаксическом анализе кода</li>
    </ul>
    <h3>явная/неявная</h3>
    <p><b>Явная типизация:</b> типы языковых элементов (сигнатура функций и т.д.) явно прописывается в коде. </p>
    <ul>Плюсы:
      <li>делает код более понятным (читабельным)</li>
      <li>способствует развитию у разработчика навыков необходимых для проектирования архитектуры программ</li>
    </ul>
    <p><b>Неявная типизация:</b> типы языковых элементов не прописывается в коде </p>
    <ul>Плюсы:
      <li>более лаконичный код</li>
    </ul>
    <ul>Минусы:
      <li>труднее разобраться в коде</li>
    </ul>

    <h3>Структурная / номинативная</h3>
    <p><b>Структурная типизация:</b> определяет совместимость типов основываясь не на иерархии наследования или явной
      реализации интерфейсов, а на их описании. Компилятор считает типы совместимыми, если сопоставляемый тип имеет все
      признаки типа, с которым сопоставляется. Чтобы быть совместимым, сопоставляемый тип должен иметь те же ключи с
      теми же (идентичными или совместимыми) типами, что и тип, с которым происходит сопоставление</p>
    <p><b>Номинативная типизация:</b> устанавливает совместимость типов основываясь на идентификаторах типов (ссылках).
      При проверке на совместимость компилятор проверяет иерархию типов на признаки наследования и
      реализацию интерфейсов. То есть, тип B будет совместим с типом A только тогда, когда он является его предком
      (extends). Кроме того, тип B будет совместим с интерфейсом IA только в том случае, если он или один из его предков
      реализует его явно (implements)</p>
    <p>Как работает структурная типизация в Typescript:</p>
    <pre><code>
    class Car {
      id: number;
      numberOfWheels: number;
      move (x: number, y: number) {
          // некая реализация
      }
  }
    
    class Boat {
        id: number;
        move (x: number, y: number) {
            // некая реализация
        }
    }
    
    let car: Car = new Boat(); // здесь TypeScript выдаст ошибку, в Boat отсутствует свойство numberOfWheels
    let boat: Boat = new Car(); // а на этой строчке все в порядке - Класс Car содержит все свойства и методы класса Boat, поэтому Car может использоваться в качестве Boat
    </code></pre>


    <h2 id="js-ts-typing">Какие виды типизации используются в JavaScript и TypeScript?</h2>

    <p><b>JavaScript:</b> Динамическая | Слабая | Неявная</p>
    <p><b>TypeScript:</b> Статическая | Сильная | Явная | Структурная</p>


    <h2 id="data-types">Как и для каких целей используются типы данных, приведенные ниже?</h2>
    <h3>Boolean</h3>
    <p></p>
    <h3>Number</h3>
    <p></p>
    <h3>String</h3>
    <p></p>
    <h3>Null and Undefined</h3>
    <p></p>
    <h3>Object and object</h3>
    <p></p>
    <h3>Array</h3>
    <p></p>
    <h3>Tuple</h3>
    <p></p>
    <h3>Enum</h3>
    <p>Enum — это конструкция, состоящая из набора именованных констант, именуемая списком перечисления и определяемая
      такими примитивными типами, как number и string. Enum объявляется с помощью ключевого слова enum</p>
    <h3>Any</h3>
    <p>Используетя, если тип конструкций может быть неизвестен. Примером этого может служить сервис, который работает с
      сервером посредством api. Полученные и сериализованные данные могут храниться как тип any прежде чем они будут и
      преобразованы к конкретному типу.</p>
    <p>Тип any является уникальным для TypeScript, в JavaScript подобного типа не существует. Any является базовым для
      всех остальных типов. Все типы в TypeScript являются его подтипами. Это означает, что он совместим в обе стороны с
      любым другим типом и с точки зрения системы типов является высшим типом (top type).</p>
    <h3>Void</h3>
    <p>Тип данных Void можно назвать полной противоположностью типа any, так как этот тип означает отсутствие
      конкретного типа. Основное предназначение типа Void — явно указывать на то, что у функции или метода отсутствует
      возвращаемое значение.</p>
    <h3>Never</h3>
    <p>Примитивный типа данных Never служит для указания того, что какие-либо операции никогда не будут выполнены.</p>
    <h3>Unknown</h3>
    <p>Тип Unknown является типобезопасным аналогом типа any и представлен в виде литерала unknown. Тип unknown
      позволяется использовать только в операциях равенства ===, ==, !== и != и в операциях с логическими операторами
      &&, || и !.</p>




    <h2 id="Union-intersection">Union и intersection типы</h2>
    <h3>Для чего нужны?</h3>
    <p>Позволяют скомбинировать существующие типы вместо того, чтобы создать их с нуля</p>
    <h3>Как использовать?</h3>
    <p> <b> Объединение (Union) </b>— это механизм, позволяющий создавать из множества существующих типов логическое
      условие, по которому данные могут принадлежать только к одному из указанных типов. Объединение указывается с
      помощью оператора прямой черты |, по обе стороны которой располагаются типы данных.</p>
    <pre><code>
        let v1: T1 | T2 | T3;
      </code></pre>
    <p>Переменной, которой был указан тип объединения A или B или C, может быть присвоено значение, принадлежащие к
      одному из трех типов.</p>

    <p> <b>Пересечение (Intersection)</b> — ещё один механизм TypeScript, который позволяет рассматривать множество
      типов
      данных как единое целое. Пересечение указывается с помощью оператора амперсанда & по обе стороны от которого
      указываются типы данных.</p>
    <pre><code>
        let v1: T1 & T2 & T3;
      </code></pre>
    <p>Переменной, которой был указан тип пересечение A и B и С должно быть присвоено значение принадлежащее к типам A и
      B и C одновременно. Другими словами значение должно обладать всеми обязательными признаками каждому типа
      определяющего пересечение.</p>
    <b> Пояснение человеческим языком <a
        href="https://ru.stackoverflow.com/questions/876192/%D0%9F%D0%BE%D1%87%D0%B5%D0%BC%D1%83-%D0%B2-typescript-%D0%BF%D0%B5%D1%80%D0%B5%D1%81%D0%B5%D1%87%D0%B5%D0%BD%D0%B8%D0%B5-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-%D1%82%D0%BE-%D1%87%D1%82%D0%BE-%D0%BE%D0%B7%D0%BD%D0%B0%D1%87%D0%B0%D0%B5%D1%82-%D0%BE%D0%B1%D1%8A%D0%B5%D0%B4%D0%B8%D0%BD%D0%B5%D0%BD%D0%B8%D0%B5-%D0%B2-%D1%82%D0%B5%D0%BE%D1%80%D0%B8%D0%B8-%D0%BC%D0%BD">Читать
        здесь >></a> и <a
        href="https://stackoverflow.com/questions/38855908/naming-of-typescripts-union-and-intersection-types">здесь</a></b>













  </main>

</body>

</html>