<!doctype html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<script defer src="./main.js"></script>
	<link rel="stylesheet" href="./index.css">
</head>

<body>
	<p>
		Содержание
	<ul>
		<li>
			<a href="#tables">Таблицы</a>
		</li>
		<li>
			<a href="#checkbox-radio">Чекбоксы и радиокнопки</a>
		</li>
		<li>
			<a href="#label">Label</a>
		</li>
	</ul>
	</p>
	<h1 id="html">HTML</h1>
	<h2 id="tables">Таблицы</h2>
	<h3>Как создавать таблицы в html?</h3>
	<p>
		Общая информация по таблицам.
		Табличные данные относятся к категории потокового содержимого, они используются в основной части документов и
		приложений.
		В таблицах есть строки, столбцы и ячейки. Строки и столбцы образуют сетку. Ячейки таблицы должны полностью
		заполнять эту сетку без перекрытия.
		Таблицы нельзя использовать в качестве вспомогательных средств разметки. Исторически сложилось так, что некоторые
		веб-авторы неправильно использовали таблицы в HTML как способ управления макетом своих страниц. Это использование
		не соответствует требованиям, поскольку инструменты, пытающиеся извлечь данные из таких документов, могут получить
		запутанные результаты. В частности, программам чтения с экрана будет сложно перемещаться по страницам с таблицами,
		используемыми для разметки.
		Если таблица все же должна использоваться для разметки страницы, ее необходимо пометить атрибутом
		role=&quotpresentation&quot, чтобы браузер правильно представлял таблицу программам чтения с экрана.</p>
	<p>Теги для создания таблиц:</p>
	<p>&lttable&gt - таблица</p>
	<p>&ltcaption&gt - подпись таблицы
	<p> &ltcolgroup&gt - Элемент &ltcolgroup&gt и его атрибут span участвует в макете таблицы, представляя группу из
		одного или нескольких столбцов.
		<i>Примечание: Элемент &ltcolgroup&gt должен использоваться внутри элемента &lttable&gt сразу после элемента
			&ltcaption&gt перед элементами &ltthead&gt, &lttbody&gt, &lttfoot&gt и &lttr&gt.</i>
	</p>
	<p> &ltcol&gt - Элемент &ltcol&gt и его атрибут span участвует в макете таблицы, представляя один или несколько
		столбцов в группе столбцов, представленных элементом &ltcolgroup&gt.</p>
	<p> &lttbody&gt основные данные таблицы.</p>
	<p> &ltthead&gt - блок строк, состоящий из заголовков столбцов таблицы.</p>
	<p> &lttfoot&gt - нижние колонтитулы.</p>
	<p> &lttr&gt - строка</p>
	<p> &lttd&gt - ячейка</p>

	<table class="content-table">
		<thead>
			<tr>
				<th>Атрибут &lttd&gt</th>
				<th>Описание, принимаемое значение</th>
			</tr>
			<tr>
				<td>colspan</td>
				<td>Задает количество строк, которые должна объединять ячейка.
					Синтаксис: colspan=&quot2&quot</td>
			</tr>
			<tr>
				<td>rowspan</td>
				<td>Задает количество столбцов, которые должна объединять ячейка.
					Синтаксис: rowspan=&quot2&quot</td>
			</tr>
			<tr>
				<td>headers</td>
				<td>Задает список строк, разделенных пробелами,
					каждая из которых соответствует атрибуту id элементов &ltth&gt, которые связаны с этим элементом.
					Синтаксис: headers=&quot2&quot</td>
			</tr>
		</thead>
	</table>

	<p>
		Тег &ltth&gt предназначен для создания одной ячейки таблицы, которая обозначается как заголовочная.
		Текст в такой ячейке отображается браузером обычно жирным шрифтом и выравнивается по центру.
		Тег &ltth&gt должен размещаться внутри контейнера &lttr&gt, который в свою очередь располагается внутри тега
		&lttable&gt.
	</p>

	<table class="content-table">
		<thead>
			<tr>
				<th>Атрибут &lttd&gt</th>
				<th>Описание, принимаемое значение</th>
			</tr>
			<tr>
				<td>colspan</td>
				<td>Задает количество строк, которые должна объединять ячейка.
					Синтаксис: colspan=&quot2&quot</td>
			</tr>
			<tr>
				<td>rowspan</td>
				<td>Задает количество столбцов, которые должна объединять ячейка.
					Синтаксис: rowspan=&quot2&quot</td>
			</tr>
			<tr>
				<td>headers</td>
				<td>Задает список строк, разделенных пробелами,
					каждая из которых соответствует атрибуту id элементов &ltth&gt, которые связаны с этим элементом.
					Синтаксис: headers=&quot2&quot</td>
			</tr>

			<tr>
				<td>scope</td>
				<td>Определяет ячейки, к которым относится заголовок, определенный в элементе &ltth&gt.
					Разрешенные значения:
					row — заголовок относится ко всем ячейкам строки, к которой он принадлежит.
					col — заголовок относится ко всем ячейкам столбца, которому он принадлежит.
					rowgroup — заголовок принадлежит группе строк и относится ко всем ее ячейкам. Эти ячейки могут быть
					размещены справа или слева от заголовка, в зависимости от значения атрибута dir элемента &lttable&gt.
					colgroup — заголовок принадлежит &ltcolgroup&gt и относится ко всем ее ячейкам.
					Синтаксис: scope=&quotrowgroup&quot
				</td>
			</tr>

			<tr>
				<td>abbr</td>
				<td>Задает альтернативное сокращенное описание содержимого ячейки. Программы для чтения речи могут
					представлять это описание перед самим контентом.
					Синтаксис: abbr=&quotTypes&quot</td>
			</tr>
		</thead>
	</table>
	<h3> border-spacing, border-collapse</h3>
	С помощью свойства <b>border-spacing</b> можно менять расстояние между рамками ячеек. Данное свойство применяется к
	таблице в целом.
	Рамки ячеек таблицы по умолчанию разделены небольшим промежутком. Если задать для таблицы<b> border-collapse:
		collapse</b>, то промежуток уберётся

	<h3>colspan, rowspan</h3>
	Это атрибуты ячеек (т.е. тегов &lttd&gt и &ltth&gt).
	Colspan задает, сколько столбцов объединяет ячейка, а rowspan – сколько строк


	<h3>table-layout</h3>
	<p>Компоновка макета таблицы определяется одним из двух подходов: фиксированный макет или автоматический макет. Под
		компоновкой в данном случае подразумевается, как распределяется ширина таблицы между шириной ячеек.
		Свойство не наследуется.
	</p>


	<table class="content-table">
		<thead>
			<tr>
				<th colspan="2">table-layout</th>
			</tr>
			<tr>
				<td>auto</td>
				<td>Значение по умолчанию. Ширина макета таблицы определяется шириной её содержимого
					с учетом значений свойств <b>padding-left</b>, <b>padding-right</b>, <b>border-left width</b> плюс одна
					ширина <b>border-right</b> последней ячейки в ряду,
					или заданной шириной ячеек и толщиной рамки. Если ширина ячеек не задана явно, они могут быть разной
					ширины.</td>
			</tr>
			<tr>
				<td>fixed</td>
				<td>Ширина колонок в этом случае определяется либо с помощью тега &ltcol&gt,
					либо вычисляется на основе первой строки. Если данные о форматировании первой строки
					таблицы по каким-либо причинам получить невозможно, в этом случае таблица делится
					на колонки равной ширины. При использовании этого значения, содержимое, которое не
					помещается в ячейку указанной ширины, будет «обрезано» либо наложено поверх ячейки.
					Это зависит от используемого браузера, но в любом случае ширина ячейки меняться не будет.
					Для корректной работы этого значения обязательно должна быть задана ширина таблицы.</td>
			</tr>
		</thead>
	</table>

	<h3>caption</h3>

	&ltcaption&gt - подпись таблицы
	Если элемент &lttable&gt является единственным содержимым в элементе &ltfigure&gt, кроме &ltfigcaption&gt,
	элемент &ltcaption&gt следует опустить в пользу &ltfigcaption&gt.

	<h3>headers & scope</h3>

	<p>Атрибут <b>headers</b> позволяет связать ячейки таблицы с заголовками. Этот атрибут предназначен для повышения
		доступности таблицы пользователям речевых браузеров, в обычных браузерах результат применения атрибута
		<b>headers</b> не заметен.
	</p>
	<p>Для связывания ячеек между собой одной ячейке в теге <td> или
		<th> задается атрибут <b>id</b>, а второй ячейке — атрибут <b>headers</b> со значением, совпадающим со значением
			<b>id</b>.
	</p>
	<p>Синтаксис
	<p>&lttd id="идентификатор"&gt...&lt /td&gt </p>
	<p>&lt td headers="идентификатор"&gt...&lt /td&gt </p>

	<p>Атрибут <b>scope</b> связывает между собой ячейки с заголовком и обычные ячейки. По своему действию напоминает
		атрибут <b>headers</b>, но используется для простых таблиц. Атрибут предназначен для экранных ридеров вроде
		речевых браузеров, в обычных браузерах результат добавления <b>scope</b> никак не заметен. </p>
	<p>Синтаксис</p>
	<p>&lt td scope="col | colgroup | row | rowgroup">...&lt /td&gt </p>
	<p>Значения</p>
	<p><b>col</b> - >Ячейка заголовка установлена для колонки. </p>
	<p><b>colgroup</b> - Ячейка заголовка установлена для группы колонок. </p>
	<p><b>row</b> - Ячейка заголовка задана для строки. </p>
	<p><b>rowgroup</b> - Ячейка заголовка установлена для группы строк. </p>

	<h3>display: table, table-cell, table-row и т.д.</h3>
	<p>Используется для задания не специализированному табличному тегу (например &ltdiv&gt) поведения,
		аналогичного тегам &lttable&gt, &lttr&gt, &lttd&gt и т.д.</p>

	<table class="content-table">
		<thead>
			<tr>
				<th colspan="2">Значение свойства Display</th>
			</tr>
			<tr>
				<td>table</td>
				<td>Элемент генерирует структурный блок. На странице ведет себя аналогично &lttable&gt.</td>
			</tr>
			<tr>
				<td>table-caption</td>
				<td>Элемент генерирует основной заголовок таблицы. На странице ведет себя аналогично &ltcaption&gt.</td>
			</tr>
			<tr>
				<td>table-column</td>
				<td>Элемент описывает столбец ячеек, визуальное представление не генерируется. Аналог — &ltcol&gt.</td>
			</tr>
			<tr>
				<td>table-column-group</td>
				<td>Элемент объединяет один или несколько столбцов. Аналог — &lt colgroup&gt.</td>
			</tr>
			<tr>
				<td>table-cell</td>
				<td>Элемент генерирует отдельную ячейку таблицы, на странице ведет себя аналогично &lt th&gt и &lt td&gt.
				</td>
			</tr>
			<tr>
				<td>table-header-group</td>
				<td>Элемент определяет группу строк заголовка, которая всегда отображается перед остальными строками и
					группами строк. Аналог — &lt thead&gt.</td>
			</tr>
			<tr>
				<td>table-footer-group</td>
				<td>Элемент определяет группу строк заголовка, которая всегда отображается после всех остальных строк и
					перед любым нижним основным заголовком. Ведет себя аналогично &lt tfoot>.</td>
			</tr>
			<tr>
				<td>table-row-group</td>
				<td>Элемент объединяет одну или несколько строк. Аналог — &lt tbody&gt</td>
			</tr>
			<tr>
				<td>table-row</td>
				<td>Элемент является строкой ячеек. Пример — &lt tr&gt.</td>
			</tr>
		</thead>
	</table>


	<h3>Примеры верстки</h3>

	<br>
	<section>
		<table id="table5">
			<caption><b>Использованы атрибуты headers и scope</b></caption>
			<thead>
				<tr>
					<th id="TH10" scope="col">заголовок первой колонки</th>
					<th id="TH20" scope="col">заголовок второй колонки</th>
					<th id="TH30" scope="col">заголовок третьей колонки</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td headers="TH10">TD внутри TBODY 1</td>
					<td headers="TH20">TD внутри TBODY 2</td>
					<td headers="TH30">TD внутри TBODY 3</td>
				</tr>
			</tbody>
			<tfoot>
				<tr>
					<th scope="row">TH внутри TFOOT</th>
					<td>TD внутри TFOOT</td>
					<td>TD внутри TFOOT</td>
					<td>TD внутри TFOOT</td>
				</tr>
			</tfoot>
		</table>
		<pre>
		<code>
			&lttable id=&quottable5&quot&gt
			&ltcaption&gt&ltb&gtTABLE 5&lt/b&gt&lt/caption&gt
		
			&ltthead&gt
				&lttr&gt
					&ltth&gt id=&quotTH10&quot scope=&quotcol&quot&gtзаголовок первой колонки&lt/th&gt
					&ltth&gt id=&quotTH20&quot scope=&quotcol&quot&gtзаголовок второй колонки&lt/th&gt
					&ltth&gt id=&quotTH30&quot scope=&quotcol&quot&gtзаголовок третьей колонки&lt/th&gt
				&lt/tr&gt
			&lt/thead&gt
			&lttbody&gt
		
				&lttr&gt
					&lttd&gt <b>headers=&quotTH10&quot</b>&gtTD внутри TBODY 1&lt/td&gt
					&lttd&gt <b>headers=&quotTH20&quot</b>&gtTD внутри TBODY 2&lt/td&gt
					&lttd&gt <b>headers=&quotTH30&quot</b>&gtTD внутри TBODY 3&lt/td&gt
				&lt/tr&gt
		
			&lt/tbody&gt
			&lttfoot&gt
				&lttr&gt
					&ltth&gt <b>scope=&quotrow&quot</b>&gtTH внутри TFOOT&lt/th&gt
					&lttd&gtTD внутри TFOOT&lt/td&gt
					&lttd&gtTD внутри TFOOT&lt/td&gt
					&lttd&gtTD внутри TFOOT&lt/td&gt
				&lt/tr&gt
			&lt/tfoot&gt
		&lt/table&gt
		</code>
	</pre>
	</section>
	<br>
	<section>
		<table rules='groups'>
			<colgroup>
				<col id='col1' span=2>
				<col id='col2' span=3>
				<col id='col3' span=1>
				<col id='col4' span=2>
				<col id='col5' span=1>
			</colgroup>
			<caption><b>Таблице добавлен атрибут rules='groups'; использованы теги &ltcolgroup&gt и &ltcol&gt</b></caption>
			<thead>
				<tr>
					<th id="n">TH внутри TR внутри THEAD</th>
					<th>TH внутри TR внутри THEAD</th>
					<th>TH внутри TR внутри THEAD</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td headers="n r1-с1">TD внутри TBODY 1</td>
					<th id="r1-с1">TH внутри TBODY 2</th>
					<td>TD внутри TBODY 3</td>
					<td headers="n r1-с2">TD внутри TBODY 4</td>
					<th id="r1-с2">TH внутри TBODY 5</th>
					<td>TD внутри TBODY 6</td>
					<td headers="n r1-с3">TD внутри TBODY 7</td>
					<th id="r1-с3">TH внутри TBODY 8</th>
					<td>TD внутри TBODY 9</td>
				</tr>
			</tbody>
			<tfoot>
				<tr>
					<th scope="row">TH внутри TFOOT</th>
					<td>TD внутри TFOOT</td>
					<td>TD внутри TFOOT</td>
					<td>TD внутри TFOOT</td>
				</tr>
			</tfoot>
		</table>
		<pre>
	<code>
	<b>&lttable rules='groups'&gt</b>
	<b>&ltcolgroup&gt
			&ltcol id='col1' span=2&gt
			&ltcol id='col2' span=3&gt
			&ltcol id='col3' span=1&gt
			&ltcol id='col4' span=2&gt
			&ltcol id='col5' span=1&gt
		&lt/colgroup&gt</b>

		&ltcaption&gt&ltb&gtTABLE 1&lt/b&gt&lt/caption&gt

		&ltthead&gt
			&lttr&gt
				&ltth id=&quotn&quot&gtTH внутри TR внутри THEAD&lt/th&gt
				&ltth&gtTH внутри TR внутри THEAD&lt/th&gt
				&ltth&gtTH внутри TR внутри THEAD&lt/th&gt
			&lt/tr&gt
		&lt/thead&gt
		&lttbody&gt

			&lttr&gt
				&lttd headers=&quotn r1-с1&quot&gtTD внутри TBODY 1&lt/td&gt
				&ltth id=&quotr1-с1&quot&gtTH внутри TBODY 2&lt/th&gt
				&lttd&gtTD внутри TBODY 3&lt/td&gt

				&lttd headers=&quotn r1-с2&quot&gtTD внутри TBODY 4&lt/td&gt
				&ltth id=&quotr1-с2&quot&gtTH внутри TBODY 5&lt/th&gt
				&lttd&gtTD внутри TBODY 6&lt/td&gt

				&lttd headers=&quotn r1-с3&quot&gtTD внутри TBODY 7&lt/td&gt
				&ltth id=&quotr1-с3&quot&gtTH внутри TBODY 8&lt/th&gt
				&lttd&gtTD внутри TBODY 9&lt/td&gt
			&lt/tr&gt
		&lt/tbody&gt
		&lttfoot&gt
			&lttr&gt
				&ltth scope=&quotrow&quot&gtTH внутри TFOOT&lt/th&gt
				&lttd&gtTD внутри TFOOT&lt/td&gt
				&lttd&gtTD внутри TFOOT&lt/td&gt
				&lttd&gtTD внутри TFOOT&lt/td&gt
			&lt/tr&gt
		&lt/tfoot&gt
	&lt/table&gt
	</code>
</pre>
	</section>
	<br>
	<section>
		<table id="table2">
			<caption><b>Использованы атрибуты colspan и rowspan для ячеек, к таблице применено свойство border-collapse:
					collapse;</b></caption>
			<thead>
				<tr>
					<th id="n">TH внутри TR внутри THEAD</th>
					<th>TH внутри TR внутри THEAD</th>
					<th colspan="3" id="th1">TH внутри TR внутри THEAD занимает три столбца</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td headers="n r1-с1" colspan="1" id="td1">TD внутри TBODY 1 занимает один столбец</td>
					<th id="r1-с1" rowspan="3">TH внутри TBODY 2 занимает три строки</th>
				</tr>
				<tr>
					<td headers="n r2">TD внутри TBODY 1</td>
				</tr>
				<tr>
					<td>TD внутри TBODY 1</td>
				</tr>
				<tr>
					<td>TD внутри TBODY 1</td>
				</tr>
			</tbody>
		</table>
		<pre>
	<code>
		&lttable id=&quottable2&quot&gt
		&ltcaption&gt&ltb&gtTABLE 2&lt/b&gt&lt/caption&gt
		&ltthead&gt
			&lttr&gt
				&ltth&gt id=&quotn&quot&gtTH внутри TR внутри THEAD&lt/th&gt
				&ltth&gtTH внутри TR внутри THEAD&lt/th&gt
				&ltth&gt <b>colspan=&quot3&quot</b> id=&quotth1&quot&gtTH внутри TR внутри THEAD занимает три столбца&lt/th&gt
			&lt/tr&gt
		&lt/thead&gt
		&lttbody&gt
			&lttr&gt
				&lttd&gt headers=&quotn r1-с1&quot <b>colspan=&quot1&quot</b> id=&quottd1&quot&gtTD внутри TBODY 1 занимает один столбец&lt/td&gt
				&ltth&gt id=&quotr1-с1&quot <b>rowspan=&quot3&quot</b>&gtTH внутри TBODY 2 занимает три строки&lt/th&gt
			&lt/tr&gt
			&lttr&gt
				&lttd&gt headers=&quotn r2&quot&gtTD внутри TBODY 1&lt/td&gt
			&lt/tr&gt
			&lttr&gt
				&lttd&gtTD внутри TBODY 1&lt/td&gt
			&lt/tr&gt
			&lttr&gt
				&lttd&gtTD внутри TBODY 1&lt/td&gt
			&lt/tr&gt
		&lt/tbody&gt
	&lt/table&gt
	</code>
</pre>
	</section>
	<br>
	<section>
		<table id="table3">
			<caption><b>Применены свойства border-spacing: 5px; table-layout: fixed (колонки одинаковой ширины);</b>
			</caption>
			<thead>
				<tr>
					<th>TH внутри TR внутри THEAD</th>
					<th>TH внутри TR внутри THEAD</th>
					<th>TH внутри TR внутри THEAD</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>TD внутри TBODY 1</td>
					<td>TD внутри TBODY 2</td>
					<td>TD внутри TBODY 3</td>
					<td>TD внутри TBODY 4</td>
					<td>TD внутри TBODY 5</td>
				</tr>
				<tr>
					<td>TD внутри TBODY 1</td>
					<td>TD внутри TBODY 2</td>
					<td>TD внутри TBODY 3</td>
					<td>TD внутри TBODY 4</td>
					<td>TD внутри TBODY 5 test test test test test test test test test test </td>
				</tr>
			</tbody>
			<tfoot>
				<tr>
					<th scope="row">TH внутри TFOOT</th>
					<td>TD внутри TFOOT</td>
					<td>TD внутри TFOOT</td>
					<td>TD внутри TFOOT</td>
				</tr>
			</tfoot>
		</table>
		<pre>
			<code>
				table {
					border: 1px solid rgb(93, 177, 226);
					border-spacing: 5px;
					table-layout: fixed;
					width: 500px;
				}
			</code>
		</pre>
	</section>
	<br>
	<section>
		<table id="table4">
			<caption><b>Применены свойства border-spacing: 5px; table-layout: auto; (колонки разной ширины,
					которая зависит от
					содержимого)</b></caption>
			<thead>
				<tr>
					<th>TH внутри TR внутри THEAD</th>
					<th>TH внутри TR внутри THEAD</th>
					<th>TH внутри TR внутри THEAD</th>
				</tr>
			</thead>
			<tbody>
				<tr>
					<td>TD внутри TBODY 1</td>
					<td>TD внутри TBODY 2</td>
					<td>TD внутри TBODY 3</td>
					<td>TD внутри TBODY 4</td>
					<td>TD внутри TBODY 5</td>
				</tr>
				<tr>
					<td>TD внутри TBODY 1</td>
					<td>TD внутри TBODY 2</td>
					<td>TD внутри TBODY 3</td>
					<td>TD внутри TBODY 4</td>
					<td>TD внутри TBODY 5 test test test test test test test test test test </td>
				</tr>
			</tbody>
			<tfoot>
				<tr>
					<th scope="row">TH внутри TFOOT</th>
					<td>TD внутри TFOOT</td>
					<td>TD внутри TFOOT</td>
					<td>TD внутри TFOOT</td>
				</tr>
			</tfoot>
		</table>
		<pre>
		<code>
			table {
				border: 1px solid rgb(93, 177, 226);
				border-spacing: 5px;
				table-layout: auto;
				width: 500px;
			}
		</code>
	</pre>
	</section>



	<h2 id="checkbox-radio">Чекбоксы и радиокнопки</h2>
	<h3>В чем заключаются отличие чекбокса от радио кнопок? Как связать радиокнопки в группу?</h3>
	<p>Отличие в том, что активных чекбоксов в группе может быть от нуля до всех из них, а в группе радиокнопок всегда
		активна только одна</p>
	<p>
		Чекбокс - это элемент &ltinput&gt с атрибутом <b>type=&quotcheckbox&quot</b>
	</p>
	<p>
		Радиокнопка - это тоже элемент &ltinput&gt, но с атрибутом <b>type=&quotradio&quot</b>. Чтобы связать радиокнопки
		в группу,
		каждому элементу нужно прописать атрибут <b>name</b> с именем группы радиокнопок (т.е. значение <b>name</b> должно
		быть одинаковым у всех кнопок в группе,
		тогда можно будет выбрать только одну из них).
		Добавление атрибута <b>name</b> элементам группы чекбоксов не имеет такого же эффекта
	</p>
	<section>
		<fieldset style="max-width: 200px;">
			<legend>Чекбоксы</legend>
			<label>
				<input type="checkbox" name="checkroup"> 1
			</label>
			<label>
				<input type="checkbox" name="checkroup"> 2
			</label>
			<label>
				<input type="checkbox" name="checkroup"> 3
			</label>
		</fieldset>
		<pre>
			<code>
				&ltfieldset style=&quotmax-width: 200px;&quot>
				&ltlegend&gtЧекбоксы&lt/legend>
				&ltlabel&gt
					&ltinput type=&quotcheckbox&quot name=&quotcheckroup&quot&gt 1
				&lt/label&gt
				&ltlabel&gt
					&ltinput type=&quotcheckbox&quot name=&quotcheckroup&quot&gt 2
				&lt/label&gt
				&ltlabel&gt
					&ltinput type=&quotcheckbox&quot name=&quotcheckroup&quot&gt 3
				&lt/label&gt
			&lt/fieldset&gt
			</code>
		</pre>
	</section>
	<section>
		<fieldset style="max-width: 200px;">
			<legend>Радиокнопки</legend>
			<label>
				<input type="radio" name="radiogroup" checked> 1
			</label>
			<label>
				<input type="radio" name="radiogroup"> 2
			</label>
			<label>
				<input type="radio" name="radiogroup"> 3
			</label>
		</fieldset>
		<pre>
			<code>
				&ltfieldset style=&quotmax-width: 200px;&quot&gt
				&ltlegend&gtРадиокнопки&lt/legend&gt
				&ltlabel&gt
					&ltinput type=&quotradio&quot name=&quotradiogroup&quot checked&gt 1
				&lt/label&gt
				&ltlabel&gt
					&ltinput type=&quotradio&quot name=&quotradiogroup&quot&gt 2
				&lt/label&gt
				&ltlabel&gt
					&ltinput type=&quotradio&quot name=&quotradiogroup&quot&gt 3
				&lt/label&gt
			&lt/fieldset&gt
			</code>
		</pre>
	</section>

	<h2 id="label">Что такое тег &ltlabel&gt и как с ним работать?</h2>

	<p>
		Тег &ltlabel&gt устанавливает связь между определенной меткой, в качестве которой обычно выступает текст,
		и элементом формы (&ltinput&gt, &ltselect&gt, &lttextarea&gt).
		Такая связь необходима, чтобы изменять значения элементов формы при нажатии курсором мыши на текст. Кроме того,
		с помощью &ltlabel&gt можно устанавливать горячие клавиши на клавиатуре и переходить на активный элемент подобно
		ссылкам.

		Существует два способа связывания объекта и метки. Первый заключается в использовании идентификатора id внутри
		элемента
		формы и указании его имени в качестве атрибута for тега &ltlabel&gt. При втором способе элемент формы помещается
		внутрь
		контейнера &ltlabel&gt.
	</p>
	<section>
		<form action="" class="content-form">
			</div>
			<input type="checkbox" id="check1">
			<label for="check1">&ltlabel&gt связан с чекбоксом по ID</label>
			</div>
			<div>
				<label>
					<input type="checkbox">
					&ltlabel&gt обернут вокруг чекбокса</label>
			</div>
		</form>
		<pre><code>
		&ltform action=&quot&quot class=&quotcontent-form&quot&gt
		&lt/div&gt
		&lt!-- Вариант 1 --&gt
			&ltinput type=&quotcheckbox&quot id=&quotcheck1&quot&gt
			&ltlabel&gt for=&quotcheck1&quot&gt связан с чекбоксом по ID&lt/label&gt
		&lt/div&gt
		&ltdiv&gt
		&lt!-- Вариант 2 --&gt
			&ltlabel&gt
			&ltinput type=&quotcheckbox&quot&gt
			обернут вокруг чекбокса&lt/label&gt
		&lt/div&gt
	&lt/form&gt

	</code></pre>
	</section>

	<h2 id="bem">БЭМ</h2>
	<h3>Что такое БЭМ и в чем его польза?</h3>
	<p>БЭМ (Блок, Элемент, Модификатор) — компонентный подход к веб-разработке.
		В его основе лежит принцип разделения интерфейса на независимые блоки.
		Он позволяет легко и быстро разрабатывать интерфейсы любой сложности и повторно
		использовать существующий код, избегая «Copy-Paste».</p>
	<h3>Блок</h3>
	<h4>Что такое, когда следует создавать?</h4>
	<p>
		Функционально независимый компонент страницы, который может быть повторно использован.
		Имя блока всегда уникально. Оно задает пространство имен для элементов и устанавливает видимую связь между всеми
		составляющими блока. Если фрагмент кода может использоваться повторно и не зависит от реализации других
		компонентов страницы -
		надо создавать блок.</p>
	<p>Особенности:</p>

	<p>Название блока характеризует смысл («что это?» — «меню»: menu, «кнопка»: button),
		а не состояние («какой, как выглядит?» — «красный»: red, «большой»: big).</p>
	<h4>Может ли блок содержать другие блоки?</h4>
	<p>
		Блоки можно вкладывать друг в друга. Допустима любая вложенность блоков.
	</p>
	<h4>Почему не стоит задавать внешнюю геометрию блокам?</h4>
	<p>
		Блок не должен влиять на свое окружение, т. е. блоку не следует задавать внешнюю геометрию
		(в виде отступов, границ, влияющих на размеры) и позиционирование
	</p>

	<h3>Элемент</h3>
	<h4>Что такое, когда следует создавать?</h4>
	<p>
		Составная часть блока, которая не может использоваться в отрыве от него.
		Если фрагмент кода не может использоваться самостоятельно, без родительской сущности (блока) - создавайте элемент.
	</p>
	<p>Особенности:
	</p>
	<p> Название элемента характеризует смысл («что это?» — «пункт»: item, «текст»: text),
		а не состояние («какой, как выглядит?» — «красный»: red, «большой»: big).</p>
	<p>Структура полного имени элемента соответствует схеме: имя-блока__имя-элемента.
		Имя элемента отделяется от имени блока двумя подчеркиваниями (__).</p>
	<h4>Может ли элемент содержать другие элементы?</h4>
	<p>Элементы можно вкладывать друг в друга, допустима любая вложенность элементов.</p>
	<h4>Может ли элемент содержать блоки (блок, к которому он относится, или другие блоки)?</h4>
	<p>Нет</p>
	<h4>Можно ли создавать элемент элемента?</h4>
	<p>Нет. Элемент — всегда часть блока, а не другого элемента. Это означает, что в названии
		элементов нельзя прописывать иерархию вида block__elem1__elem2. Исключение составляют элементы, реализация которых
		для упрощения разработки требует
		разделения на более мелкие части — подэлементы.
		В БЭМ-методологии нельзя создавать элементы элементов. В подобном случае вместо элемента необходимо создавать
		служебный блок.</p>
	<h4>Может ли элемент использоваться вне блока?</h4>
	<p>Нет. Элемент — всегда часть блока и не должен использоваться отдельно от него.</p>
	<h4>Может ли существовать блок без элементов?</h4>
	<p>Да. Элемент — необязательный компонент блока. Не у всех блоков должны быть элементы.</p>
	<h3>Модификатор</h3>
	<h4>Что такое, когда следует использовать?</h4>
	<p>Модификатор - cущность, определяющая внешний вид, состояние или поведение блока либо элемента.</p>
	<p>Особенности:</p>
	<p>Название модификатора характеризует внешний вид («какой размер?», «какая тема?» и т. п. — «размер»: size_s,
		«тема»: theme_islands),
		состояние («чем отличается от прочих?» — «отключен»: disabled, «фокусированный»: focused) и поведение
		(«как ведет себя?», «как взаимодействует с пользователем?» — «направление»: directions_left-top).</p>
	<p>Имя модификатора отделяется от имени блока или элемента одним подчеркиванием (_).</p>

	<h4>Когда следует использовать булевый модификатор, а когда модификатор ключ-значение?</h4>
	<p><b>Булевый</b></p>
	<p>Используют, когда важно только наличие или отсутствие модификатора, а его значение несущественно.
		Например, «отключен»: disabled. Считается, что при наличии булевого модификатора у сущности его значение равно
		true.</p>
	<p>Структура полного имени модификатора соответствует схеме:</p>
	<p><i>имя-блока_имя-модификатора;</i></p>
	<p><i>имя-блока__имя-элемента_имя-модификатора.</i></p>

	<p><b>Ключ-значение</b></p>
	<p>Используют, когда важно значение модификатора. Например, «меню с темой оформления islands»: menu_theme_islands.
	</p>
	<p>Структура полного имени модификатора соответствует схеме:</p>
	<p><i>имя-блока_имя-модификатора_значение-модификатора;</i></p>
	<p><i>имя-блока__имя-элемента_имя-модификатора_значение-модификатора.</i></p>

	<h4>Является ли корректным следующий код:</h4>
	<code>&ltdiv class=&quotbutton_red&quot&gt Click me &lt/div&gt</code>
	<p>Исправление:</p>
	<code>&ltbutton class=&quotbutton_color_red&quot&gt Click me &lt/button&gt</code>
	<h3>Почему в CSS по БЭМ не рекомендуется использовать селекторы по id и по тегам?</h3>
	<p>Необходимо использовать только селекторы класса, т.к. классы — единственный селектор,
		который позволяет изолировать стили каждого компонента в проекте,
		повысить читаемость кода и не ограничивать повторное использование верстки.</p>
	<h3>Как препроцессоры помогают избежать боли с дублированием названий в коде?</h3>
	<p>Препроцессоры видоизменяет синтаксис в целях удобства.
		Например запись вида:
	<pre><code>
&ltul&gt
  &ltli&gtItem A&lt/li&gt
  &ltli&gtItem B&lt/li&gt
  &ltli&gtItem C&lt/li&gt
&lt/ul&gt
</code></pre>
	в pug будет преобразована в
	<pre><code>
	ul
		li Item A
		li Item B
		li Item C
	</code></pre>
	Таким образом устранено дублирование названий тегов</p>


	<h3>Какие альтернативы есть БЭМ и в чем сила/слабость каждого? Знать хотя бы 2 альтернативы данному подходу,
		плюсы/минусы подходов.</h3>
	<p>1. Различные способы организации CSS кода - OOCSS, SMACSS и др.</p>

	<a target="_blank" href="https://habr.com/ru/post/256109/">статья Способы организации CSS-кода</a>
	<br>
	<a target="_blank" href="https://russianblogs.com/article/8708134492/#1_14">статья Модульная объектно-ориентированная
		стратегия записи</a>

	<ul>Кратко различия с БЭМ:
		<li>БЭМ работает не только с CSS, но и с JavaScript.</li>
		<li>БЭМ больше схож с Web Components, чем с перечисленными решениями для CSS.</li>
		<li>БЭМ предоставляет комплексное решение по созданию архитектуры проекта и помогает организовать процессы
			разработки.</li>
	</ul>

	<a target="_blank" href="https://learn.javascript.ru/web-components">2. Web Components</a>
	<p>Кратко различия с БЭМ: </p>
	<ul>Поддержка браузеров:
		<li>Web Components не поддерживается в Safari, iOS Safari, Internet Explorer, Firefox.</li>
		<li>БЭМ работает во всех браузерах.</li>
	</ul>
	<ul>Инкапсуляция
		<li>В Web Components реализована через Shadow DOM.</li>
		<li>В БЭМ — с помощью элементов блока.</li>
	</ul>
	<ul>Работа шаблонов
		<li>В Web Components шаблоны всегда выполняются в браузере. Это может потребовать дополнительных решений проблем с
			индексацией.</li>
		<li> БЭМ генерация шаблона возможна на этапе разработки. Это позволяет отдавать готовый HTML. Шаблоны могут
			выполняться как в браузере, так и на сервере.</li>
		<li>Web Components использует императивный принцип — интерполяцию строк.</li>
		<li> БЭМ использует декларативный подход, который позволяет гибко управлять шаблонизацией и избегать повторений.
		</li>
	</ul>
	<ul>Вместо импорта HTML — сборка
		<li>Web Components использует импорт HTML, который работает непосредственно в браузере. Для объединения
			HTML-файлов
			используется инструмент Vulcanize.</li>
		<li>В БЭМ используется сборка. Для объединения файлов используются сборщики: ENB, Gulp.</li>
	</ul>
	<ul>Вместо Custom Elements — абстракция над DOM-деревом
		<li>В Web Components используются Custom Elements. Такой подход позволяет разместить на одном DOM-узле только один
			компонент.</li>
		<li>В БЭМ используется БЭМ-дерево. Такой подход позволяет размещать на одном DOM-узле несколько компонентов
			(БЭМ-сущностей).</li>
	</ul>

	<a target="_blank" href="https://itchief.ru/bootstrap/introduction">3. Bootstrap</a>
	<ul>Кратко различия с БЭМ:
		<li>Bootstrap — это свободный набор сверстанных блоков для создания сайтов и веб-приложений.</li>
		<li>БЭМ — это методология, позволяющая:</li>
		<li>создавать архитектуру проекта;</li>
		<li>разрабатывать веб-приложения независимыми блоками;</li>
		<li>упрощать поддержку проектов.</li>
	</ul>

	<h3>Что такое миксы в БЭМе и какие особенности работы с ними есть?</h3>

	<p>Микс позволяет одинаково форматировать разные HTML-элементы, совмещать поведение и стили нескольких сущностей без
		дублирования кода
		и решать задачи абстрактных блоков-оберток.
		Миксом называется одновременное размещение нескольких БЭМ-сущностей (блоков, элементов, модификаторов) на одном
		DOM-узле.</p>

	<p>Задачи, решаемые с помощью миксов:</p>
	<p> 1. Создавать семантически разные блоки с некоторыми общими стилями.</p>

	<pre><code>
	&ltform class=&quotform&quot action=&quot/&quot&gt
	&ltinput class=&quotform__search&quot name=&quots&quot&gt
	&ltinput class=&quotform__submit&quot type=&quotsubmit&quot&gt
	&lt/form&gt
</code></pre>
	<p>В селекторе класса .form описаны все стили, которые могут быть у любой формы (заказов, поиска или регистрации):
		<b>.form {}</b>
	</p>
	<p>Теперь предстоит сделать из универсальной формы форму поиска.
		Для этого в проекте необходимо создать дополнительный класс search, который отвечает только за поиск.
		Чтобы объединить стили и поведение класса .form и .search, нужно разместить эти классы на одном DOM-узле:</p>

	<pre><code>
	&lt!-- Микс блоков form и search --&gt
	&ltform&gt class=&quotform search&quot action=&quot/&quot&gt
		&ltinput class=&quotform__search&quot name=&quots&quot&gt
		&ltinput class=&quotform__submit&quot type=&quotsubmit&quot&gt
	&lt/form&gt
	</code></pre>
	<p> В данном случае класс <b>.search</b> — это отдельный блок, который определяет поведение.
		У этого блока не может быть модификаторов, отвечающих за форму, темы, размеры.
		Такие модификаторы уже есть у универсальной формы. Микс помогает совместить стили и поведение этих разных блоков.
	</p>


	<p> 2. Внешняя геометрия и позиционирование. Отказываемся от абстрактных HTML-оберток.
		Миксы применяют, чтобы расположить один блок относительно другого или позиционировать элементы внутри блока.
		В БЭМ стили, отвечающие за внешнюю геометрию и позиционирование, задаются через родительский блок.
		Отступ от родительского блока — это не свойство вложенного блока быть с таким отступом. Это свойство родительского
		блока — знать,
		что вложенный в него блок должен отступать от границы на определенное количество пикселей.
		Для задания отступов исполь микс. Знания про позиционирование вложенных блоков описываются в элементах
		родительского
		блока.
		Затем элемент родительского блока миксуется к вложенному блоку. В таком случае вложенный блок не специфицирует
		никакие отступы и
		может быть легко переиспользован в любом месте.</p>

	<pre><code>

		&ltdiv&gt
		&lt!-- Микс блока menu и элемента header__menu --&gt
		&ltul class=&quotmenu header__menu&quot&gt
			&ltli class=&quotmenu__item&quot&gt&lta href=&quot&quot&gt&lt/a&gt&lt/li&gt
			&ltli class=&quotmenu__item&quot&gt&lta href=&quot&quot&gt&lt/a&gt&lt/li&gt
			&ltli class=&quotmenu__item&quot&gt&lta href=&quot&quot&gt&lt/a&gt&lt/li&gt
		&lt/ul&gt
		&lt/div&gt
	</code></pre>
	<p> Здесь внешняя геометрия и позиционирование блока menu задана через элемент header__menu. Блок menu не
		специфицирует
		никакие отступы и может быть легко использован повторно.
		Элемент родительского блока (в нашем случае это header__menu) полностью решает задачу абстрактных блоков-оберток,
		отвечающих за внешнее позиционирование блока.</p>





































</body>

</html>