<!doctype html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<script defer src="./main.js"></script>
	<link rel="stylesheet" href="./git.css">
</head>

<body style="padding: 10px; border: 1px solid rgb(204, 199, 199); box-shadow: 0 0 10px 10px rgb(204, 199, 199);">
	<main style="margin: 0 auto; max-width: 2400px; width: 100%;">
		<p>
			Содержание
		<ul>
			<li>
				<a href="#what-is-git">Что такое Git?</a>
			</li>
			<li>
				<a href="#git-github-gitlab">В чём разница между Git, GitHub и GitLab?</a>
			</li>
			<li>
				<a href="#areas">Что представляют из себя 3 области: Working directory, Staging area, Repository?</a>
			</li>
			<li>
				<a href="#what-is-commit">Что такое коммит?</a>
			</li>
			<li>
				<a href="#branches">Ветки</a>
			</li>
			<li>
				<a href="#git-ignore">Для чего нужен файл .gitignore?</a>
			</li>
			<li>
				<a href="#git-config">git config: что позволяет делать и какие три уровня конфигурации есть?</a>
			</li>
			<li>
				<a href="#git-commands">Что делают, как и зачем использовать команды:</a>
			</li>
			<li>
				<a href="#pull-request">Что такое Pull Request (или Merge Request)?</a>
			</li>
			<li>
				<a href="#commit-history">Как посмотреть историю коммитов?</a>
			</li>

			</p>
			<h1 id="js">GIT</h1>
			<h2 id="what-is-git">Что такое Git?</h2>
			<p> Система контроля версий (СКВ) — это система, записывающая изменения в файл или набор файлов в течение
				времени и
				позволяющая вернуться позже к определённой версии. GIT это одна из распределенных СКВ (есть также другие -
				Mercurial, Bazaar или Darcs). В РСКВ клиенты не просто скачивают снимок всех файлов (состояние файлов на
				определённый момент времени) — они полностью копируют репозиторий. В этом случае, если один из серверов,
				через который разработчики обменивались данными, умрёт, любой клиентский репозиторий может быть скопирован
				на другой сервер для продолжения работы. Каждая копия репозитория является полным бэкапом всех данных</p>
			<h2 id="git-github-gitlab">В чём разница между Git, GitHub и GitLab?</h2>
			<p>Git - распределенная система контроля версий</p>
			<p>GitLab - Git-сервер</p>
			<p>GitHub - Git-хостинг</p>
			<h2 id="areas">Что представляют из себя 3 области: Working directory, Staging area, Repository?</h2>
			<p><b>Working directory: </b>рабочая копия является снимком одной версии проекта. Эти файлы извлекаются из
				сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или
				редактировать.</p>
			<p><b>Staging area: </b>область индексирования — это файл, обычно находящийся в каталоге Git, в нём содержится
				информация о том, что попадёт в следующий коммит. Её техническое название на языке Git — «индекс», но фраза
				«область индексирования» также работает.</p>
			<p><b>Repository: </b>каталог Git — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это
				самая важная часть Git и это та часть, которая копируется при клонировании репозитория с другого компьютера.
			</p>
			<ul>У Git есть три основных состояния, в которых могут находиться ваши файлы: изменён (modified), индексирован
				(staged) и зафиксирован (committed):
				<li>К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.</li>
				<li>Индексированный — это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.
				</li>
				<li>Зафиксированный значит, что файл уже сохранён в вашей локальной базе.</li>
			</ul>
			<h2 id="what-is-commit">Что такое коммит?</h2>
			<p>Можно сказать, что коммит это основной объект в любой системе управления версиями. В нем содержится описание
				тех изменений, которые вносит пользователь в код приложения. В Git коммит состоит из нескольких так
				называемых объектов. Для простоты понимания можно считать, что коммиты это односвязный список, состоящий из
				объектов в которых содержаться измененные файлы, и ссылка на предыдущий коммит.</p>
			<p>Когда вы делаете коммит, Git сохраняет его в виде объекта, который содержит указатель на снимок (snapshot)
				подготовленных данных. Этот объект так же содержит имя автора и email, сообщение и указатель на коммит или
				коммиты непосредственно предшествующие данному (его родителей): отсутствие родителя для первоначального
				коммита, один родитель для обычного коммита, и несколько родителей для результатов слияния двух и более
				веток.

				Предположим, у вас есть каталог с тремя файлами и вы добавляете их все в индекс и создаёте коммит. Во время
				индексации вычисляется контрольная сумма каждого файла (SHA-1 как мы узнали из Что такое Git?), затем каждый
				файл сохраняется в репозиторий (Git называет такой файл блоб — большой бинарный объект), а контрольная сумма
				попадёт в индекс:
			<pre><code>
				$ git add README test.rb LICENSE
				$ git commit -m 'Initial commit'
				</code></pre>


			Когда вы создаёте коммит командой git commit, Git вычисляет контрольные суммы каждого подкаталога (в нашем
			случае, только основной каталог проекта) и сохраняет его в репозитории как объект дерева каталогов. Затем
			Git создаёт объект коммита с метаданными и указателем на основное дерево проекта для возможности воссоздать
			этот снимок в случае необходимости.

			Ваш репозиторий Git теперь хранит пять объектов: три блоб объекта (по одному на каждый файл), объект дерева
			каталогов, содержащий список файлов и соответствующих им блобов, а так же объект коммита, содержащий
			метаданные и указатель на объект дерева каталогов.</p>
			<img src="./commit-tree.JPG" alt="">
			<p>Если вы сделаете изменения и создадите ещё один коммит, то он будет содержать указатель на предыдущий
				коммит.</p>
			<img src="./commit-parents.JPG" alt="">

			<h2 id="branches">Ветки</h2>
			<h3>Что такое ветка?</h3>
			<p>Ветка в Git это подвижный указатель на один из коммитов. Обычно ветка указывает на последний коммит в
				цепочке коммитов. Ветка берет свое начало от какого-то одного коммита. Визуально это можно представить вот
				так:</p>
			<img src="./branch.JPG" alt="">
			<p>Важно понимать, что ветка берет свое начало не от ветки, а от последнего коммита который находиться в той
				ветке, в которой вы находились.
				Ветка обычно заканчивается специальным merge коммитом, который говорит, что ветку нужно объединить с
				какой-то другой веткой. В merge коммите содержатся две ссылки на два коммита которые объединяются в одну
				ветку.</p>

			<h3>Зачем нужны ветки?</h3>
			<p>Ветки нужны для того, чтобы программисты могли вести совместную работу над проектом и не мешать друг другу
				при этом. Либо чтобы один и тот же программист мог изолированно работать над разными задачами проекта</p>
			<h3>Что значит "создать ветку" и "удалить ветку" (что при этом происходит)?</h3>
			<p>При создании ветки создаётся новый указатель для дальнейшего перемещения. В момент создания ветки на коммите
				находятся два указателя - текущей ветки и вновь созданной. HEAD указывает на текущую ветку, т.е. мы
				находимся в текущей ветке, а не во вновь созданной </p>
			<p>При удалении ветки удаляется указатель на ветвь. Фиксации(коммита) все еще остаются там после удаления
				ветви, до следующей сборки мусора. </p>


			<h3>Как посмотреть список веток?</h3>
			<p>
			<pre><code>
				$ git branch
			</code></pre>
			Cимвол *, стоящий перед именем ветки в выводе команды указывает на ветку, на которой вы находитесь в настоящий
			момент (т. е. ветку, на которую указывает HEAD).</p>
			<h3>Как сменить ветку?</h3>
			<pre><code>
					$ git checkout [имя ветки, на которую переключаемся]
					или
					$ git switch [имя ветки, на которую переключаемся]
				</code></pre>
			<h3>Можно ли переключиться на другую ветку, если в рабочей директории есть изменения?</h3>
			<p>Если рабочий каталог либо индекс содержат незафиксированные изменения, конфликтующие с веткой, на которую вы
				хотите переключиться, то Git не позволит переключить ветки. Есть способы обойти это (припрятать изменения
				(stash) или добавить их в последний коммит (amend))</p>
			<h3>Как создать ветку?</h3>
			<pre><code>
					$ git branch [имя новой ветки]
				</code></pre>
			<p>Одновременное создание новой ветки и переключение на неё</p>
			<pre><code>
					git checkout -b [имя новой ветки] 
					или
					git switch -c [имя новой ветки] 
					или
					git switch --create [имя новой ветки] 
				</code></pre>
			<h3>Как переименовать ветку?</h3>
			<p> <b>Обычная ветка (не master)</b> </p>
			<p>
				Переименуйте ветку локально с помощью команды git branch --move:
			<pre><code>
	$ git branch --move bad-branch-name corrected-branch-name
</code></pre>
			Ветка bad-branch-name будет переименована в corrected-branch-name, но это изменение пока только локальное.
			Чтобы все остальные увидели исправленную ветку в удалённом репозитории, отправьте её туда:
			<pre><code>
	$ git push --set-upstream origin corrected-branch-name
</code></pre>
			Теперь проверим, где мы сейчас находимся:
			<pre><code>
	$ git branch --all
	* corrected-branch-name
	main
	remotes/origin/bad-branch-name
	remotes/origin/corrected-branch-name
	remotes/origin/main
</code></pre>
			Удаляем старую ветку:
			<pre><code>
	$ git push origin --delete bad-branch-name
</code></pre>
			</p>
			<p><b>Изменение имени главной ветки</b></p>
			<p>Все то же самое, но перед удалением старой ветки (с некорректным именем) нужно сделать следующее:
			<ul>
				<li>Все проекты, которые зависят от текущего, должны будут обновить свой код и/или конфигурацию.</li>
				<li>Обновите конфигурацию всех запускаемых тестов.</li>
				<li>Исправьте скрипты сборки и публикации артефактов.</li>
				<li>Поправьте настройки репозитория на сервере: задайте новую ветку по умолчанию, обновите правила слияния,
					а также прочие настройки, которые зависят от имени веток.</li>
				<li>Обновите документацию, исправив ссылки, указывающие на старую ветку.</li>
				<li>Слейте или отмените запросы на слияние изменений, нацеленные на старую ветку.</li>
			</ul>
			</p>
			<h3>Как удалить ветку?</h3>
			<p>Для ветки, которая слита в мастер</p>
			<pre><code>
	git branch -d [имя удаляемой ветки]
</code></pre>
			<p>Для ветки, которая не слита в мастер</p>
			<pre><code>
	git branch -D [имя удаляемой ветки]
</code></pre>

			<h2 id="git-ignore">Для чего нужен файл .gitignore?</h2>
			<p>Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий,
				но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы
				(различные логи, результаты сборки программ и т. п.). В таком случае, вы можете создать файл .gitignore. с
				перечислением шаблонов соответствующих таким файлам. Вот пример файла .gitignore:
			<pre><code>
				$ cat .gitignore
				*.[oa]
				*~
			</code></pre>
			</p>
			<p>Первая строка предписывает Git игнорировать любые файлы заканчивающиеся на «.o» или «.a» — объектные и
				архивные файлы, которые могут появиться во время сборки кода. Вторая строка предписывает игнорировать все
				файлы заканчивающиеся на тильду (~), которая используется во многих текстовых редакторах, например Emacs,
				для обозначения временных файлов. Вы можете также включить каталоги log, tmp или pid; автоматически
				создаваемую документацию; и т. д. и т. п. Хорошая практика заключается в настройке файла .gitignore до того,
				как начать серьёзно работать, это защитит вас от случайного добавления в репозиторий файлов, которых вы там
				видеть не хотите.</p>


			<h2 id="git-config">git config: что позволяет делать и какие три уровня конфигурации есть?</h2>
			<p>
			<ul>В состав Git входит утилита git config, которая позволяет просматривать и настраивать параметры,
				контролирующие все аспекты работы Git, а также его внешний вид. Эти параметры могут быть сохранены в трёх
				местах:
				<li>Файл [path]/etc/gitconfig содержит значения, общие для всех пользователей системы и для всех их
					репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и
					сохраняться именно в этот файл. Так как этот файл является системным, то вам потребуются права
					суперпользователя для внесения изменений в него.</li>
				<li>Файл ~/.gitconfig или ~/.config/git/config хранит настройки конкретного пользователя. Этот файл
					используется при указании параметра --global и применяется ко всем репозиториям, с которыми вы работаете
					в текущей системе.</li>
				<li>Файл config в каталоге Git (т. е. .git/config) репозитория, который вы используете в данный момент,
					хранит настройки конкретного репозитория. Вы можете заставить Git читать и писать в этот файл с помощью
					параметра --local, но на самом деле это значение по умолчанию. Неудивительно, что вам нужно находиться
					где-то в репозитории Git, чтобы эта опция работала правильно.</li>
			</ul>
			Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config
			перекрывают соответствующие значения в [path]/etc/gitconfig.</p>
			<p>Чтобы посмотреть все установленные настройки и узнать где именно они заданы, используйте команду:
			<pre><code>$ git config --list --show-origin</code></pre>
			</p>

			<h2 id="git-commands">Что делают, как и зачем использовать команды:</h2>
			<h3>add</h3>
			<p>Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для
				индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом
				слияния. Вам может быть понятнее, если вы будете думать об этом как «добавить этот контент в следующий
				коммит», а не как «добавить этот файл в проект».</p>
			<h3>commit</h3>
			<p>Команда commit фиксирует проиндексированные изменения. Коммит сохраняет снимок состояния вашего индекса.
				Всё, что вы не проиндексировали, так и висит в рабочем каталоге как изменённое; вы можете сделать ещё один
				коммит, чтобы добавить эти изменения в репозиторий. Каждый раз, когда вы делаете коммит, вы сохраняете
				снимок состояния вашего проекта, который позже вы можете восстановить или с которым можно сравнить текущее
				состояние.</p>
			<h4>Как и при каких условиях можно сделать коммит, не написав перед этим явно git add?</h4>
			<p>Добавление параметра -a в команду git commit заставляет Git автоматически индексировать каждый уже
				отслеживаемый на момент коммита файл, позволяя вам обойтись без git add:</p>
			<h4>Как написать сообщение для коммита не открывая редактора?</h4>
			<p>набрать свой комментарий к коммиту в командной строке вместе с командой commit указав его после параметра
				-m:
				<code><pre>
						$ git commit -m "Story 182: fix benchmarks for speed"
					</pre></code>
			</p>
			<h4>Вы забыли добавить несколько файлов в индекс и сделали коммит, но ещё не отправили изменения в удалённый
				репозиторий. Как можно добавить забытые файлы в сделанный коммит? Можно ли так делать, если вы забыли
				добавить файлы в индекс, но уже отправили сделанный коммит в удалённый репозиторий?</h4>
			<p>Если вы хотите переделать коммит — внесите необходимые изменения, добавьте их в индекс и сделайте коммит ещё
				раз, указав параметр --amend:
			<pre><code>
						$ git commit --amend
					</code></pre>
			Если забыли добавить файлы в индекс, но уже отправили сделанный коммит в удалённый репозиторий, то $ git commit
			--amend не поможет
			</p>

			<h4>Как сделать коммит, отменяющий изменения, сделанные в одном из предыдущих коммитов, с помощью revert?</h4>
			<p>
			<pre><code>
				git revert [номер проблемного коммита]
			</code></pre>
			Создаёт второй, "противоположный" коммит, "со знаком минус". После его публикации получится состояние, как до
			проблемного коммита, но в истории останется пара ненужный-коммит + отмена-ненужного-коммита.</p>
			<h3>push</h3>
			<p>Когда вы хотите поделиться своими наработками, вам необходимо отправить их в удалённый репозиторий. Команда
				для этого действия простая: git push &ltremote-name&gt &ltbranch-name&gt. Чтобы отправить вашу ветку master
				на сервер origin (повторимся, что клонирование обычно настраивает оба этих имени автоматически), вы можете
				выполнить следующую команду для отправки ваших коммитов:
			<pre><code>
					$ git push origin master
				</code></pre>
			Эта команда срабатывает только в случае, если вы клонировали с сервера, на котором у вас есть права на запись,
			и если никто другой с тех пор не выполнял команду push. Если вы и кто-то ещё одновременно клонируете, затем он
			выполняет команду push, а после него выполнить команду push попытаетесь вы, то ваш push точно будет отклонён.
			Вам придётся сначала получить изменения и объединить их с вашими и только после этого вам будет позволено
			выполнить push.</p>
			<h4>Как отправить локальную ветку, которой нет в удалённом репозитории, с помощью push?</h4>
			<p>Когда вы хотите поделиться веткой, вам необходимо отправить её на удалённый сервер, где у вас есть права на
				запись. Ваши локальные ветки автоматически не синхронизируются с удалёнными при отправке — вам нужно явно
				указать те ветки, которые вы хотите отправить. Таким образом, вы можете использовать свои личные ветки для
				работы, которую не хотите показывать, а отправлять только те тематические ветки, над которыми вы хотите
				работать с кем-то совместно.

				Если у вас есть ветка serverfix, над которой вы хотите работать с кем-то ещё, вы можете отправить её точно
				так же, как вы отправляли вашу первую ветку. Выполните команду
				<code><pre>
					$ git push [имя remote] [имя ветки], например $ git push origin my_branch
				</pre></code>
			</p>

			<h3>fetch</h3>
			<p>Для получения данных из удалённых проектов, следует выполнить:
			<pre><code>
		$ git fetch [remote-name]
	</code></pre>
			Данная команда связывается с указанным удалённым проектом и забирает все те данные проекта, которых у вас ещё
			нет. После того как вы выполнили команду, у вас должны появиться ссылки на все ветки из этого удалённого
			проекта, которые вы можете просмотреть или слить в любой момент.</p>

			<p>Когда вы клонируете репозиторий, команда clone автоматически добавляет этот удалённый репозиторий под именем
				«origin». Таким образом, git fetch origin извлекает все наработки, отправленные на этот сервер после того,
				как вы его клонировали (или получили изменения с помощью fetch). Важно отметить, что команда git fetch
				забирает данные в ваш локальный репозиторий, но не сливает их с какими-либо вашими наработками и не
				модифицирует то, над чем вы работаете в данный момент. Вам необходимо вручную слить эти данные с вашими,
				когда вы будете готовы.
			</p>
			<h4>Как стянуть и сразу переключиться на удалённую ветку, которой нет в локальном репозитории с помощью fetch и
				checkout?</h4>
			<p>
			<pre><code>
						git fetch --all && git checkout [имя ветки, на которую переключаемся]
					</code></pre>
			</p>
			<h3>merge</h3>
			<p>Эта команда осуществляет слияние веток. Например, чтобы выполнить слияние ветки hotfix с веткой master для
				включения изменений в продукт:
			<pre><code>
					$ git checkout master // переключились на master, т.е. ветку, В КОТОРУЮ мержим
					$ git merge hotfix // вливаем (вмерживаем) в ветку, в которой находимся [master] ветку hotfix
				</code></pre>
			</p>
			<h3>pull</h3>
			<p>Если ветка настроена на отслеживание удалённой ветки, то вы можете использовать команду git pull чтобы
				автоматически получить
				изменения из удалённой ветки и слить их со своей текущей. Этот способ может для вас оказаться более простым
				или более удобным. К тому же, по умолчанию команда git clone автоматически настраивает вашу локальную ветку
				master на отслеживание удалённой ветки master на сервере, с которого вы клонировали репозиторий. Название
				веток может быть другим и зависит от ветки по умолчанию на сервере. Выполнение git pull, как правило,
				извлекает (fetch) данные с сервера, с которого вы изначально клонировали, и автоматически пытается слить
				(merge) их с кодом, над которым вы в данный момент работаете.</p>

			<h3>stash</h3>
			<p>Операция stash берет изменённое состояние вашего рабочего каталога, то есть изменённые отслеживаемые файлы и
				проиндексированные изменения, и сохраняет их в хранилище незавершённых изменений, которые вы можете в любое
				время применить обратно.</p>
			<p>Такая необходимость возникает, когда надо переключиться на другую ветку, не завершив работу в текущей ветке
				и, соответственно, не закоммитив изменения, сделанные в ней (т.е. когда мы не хотим делать коммит
				незавершенных изменений, а хотим вернуться к ним позже)</p>
			<h4>Как спрятать все изменения текущей ветки?</h4>
			<p>
			<pre><code>
				git stash
				 или 
				git stash push
			</code></pre>
			</p>
			<h4>Как посмотреть список спрятанных изменений в текущей ветке?</h4>
			<p>
			<pre><code>
					git stash list
				</code></pre>
			</p>
			<h4>Как вернуть последние спрятанные изменения и удалить запись о них в истории?</h4>
			<p>
			<pre><code>
				git stash drop, указав имя удаляемых изменений
				или
				git stash pop
			</code></pre>
			</p>
			<h2>Что такое Pull Request (или Merge Request)?</h2>
			<p>Если программист достаточно опытный и ответственный, то он обычно сам сливает свой код в мастер ветку. В
				противном случае программист делает так называемый Pull запрос. Pull запрос это по сути дела запрос на
				разрешение сделать merge. Pull запрос можно сделать из web интерфейса Git, или при помощи команды git
				request-pull. После того как Pull запрос создан, остальные участники могут увидеть это, просмотреть тот код
				который программист предлагает внести в проект, и либо одобрить этот код либо нет. Merge через pull запросы
				имеет свои плюсы и минусы. Минус в том, что для тесной команды опытных программистов такой подход будет
				лишним. Это будет только тормозить работу и вносить в нее оттенки бюрократии.</p>
			<p>С другой стороны, если в проекте есть не опытные программисты, которые могут сломать код, то Pull запросы
				могут помочь избежать ошибок, и быстрее обучить этих программистов наблюдая за тем какие изменения они
				предлагают внести в код.</p>
			<p>Так же Pull запросы подходят для широкого сообщества программистов, работающих с открытым исходным кодом. В
				этом случае нельзя заранее сказать что-то о компетенции таких разработчиков и о том, что они хотят изменить
				в коде.</p>

			<h2 id="commit-history">Как посмотреть историю коммитов?</h2>
			<p>Командой git log</p>
			<p>Для просмотра истории коммитов другой ветки необходимо явно указать её имя: git log testing. Чтобы
				посмотреть
				историю по всем веткам — выполните команду с дополнительным флагом: git log --all.</p>

	</main>

</body>

</html>