<!doctype html>
<html lang="ru">

<head>
	<meta charset="UTF-8">
	<script defer src="./main.js"></script>
	<link rel="stylesheet" href="./git.css">
</head>

<body style="padding: 10px; border: 1px solid rgb(204, 199, 199); box-shadow: 0 0 10px 10px rgb(204, 199, 199);">
	<main style="margin: 0 auto; max-width: 2400px; width: 100%;">
		<p>
			Содержание
		<ul>
			<li>
				<a href="#what-is-git">Что такое Git?</a>
			</li>
			<li>
				<a href="#git-github-gitlab">В чём разница между Git, GitHub и GitLab?</a>
			</li>
			<li>
				<a href="#areas">Что представляют из себя 3 области: Working directory, Staging area, Repository?</a>
			</li>
			<li>
				<a href="#"></a>
			</li>
			<li>
				<a href="#"></a>
			</li>
			<li>
				<a href="#git-ignore">Для чего нужен файл .gitignore?</a>
			</li>
			<li>
				<a href="#git-config">git config: что позволяет делать и какие три уровня конфигурации есть?</a>
			</li>
			<li>
				<a href="#"></a>
			</li>
			<li>
				<a href="#"></a>
			</li>
			</p>
			<h1 id="js">GIT</h1>
			<h2 id="what-is-git">Что такое Git?</h2>
			<p> Система контроля версий (СКВ) — это система, записывающая изменения в файл или набор файлов в течение
				времени и
				позволяющая вернуться позже к определённой версии. GIT это одна из распределенных СКВ (есть также другие -
				Mercurial, Bazaar или Darcs). В РСКВ клиенты не просто скачивают снимок всех файлов (состояние файлов на
				определённый момент времени) — они полностью копируют репозиторий. В этом случае, если один из серверов,
				через который разработчики обменивались данными, умрёт, любой клиентский репозиторий может быть скопирован
				на другой сервер для продолжения работы. Каждая копия репозитория является полным бэкапом всех данных</p>
			<h2 id="git-github-gitlab">В чём разница между Git, GitHub и GitLab?</h2>
			<h2 id="areas">Что представляют из себя 3 области: Working directory, Staging area, Repository?</h2>
			<p><b>Working directory: </b>рабочая копия является снимком одной версии проекта. Эти файлы извлекаются из
				сжатой базы данных в каталоге Git и помещаются на диск, для того чтобы их можно было использовать или
				редактировать.</p>
			<p><b>Staging area: </b>область индексирования — это файл, обычно находящийся в каталоге Git, в нём содержится
				информация о том, что попадёт в следующий коммит. Её техническое название на языке Git — «индекс», но фраза
				«область индексирования» также работает.</p>
			<p><b>Repository: </b>каталог Git — это то место, где Git хранит метаданные и базу объектов вашего проекта. Это
				самая важная часть Git и это та часть, которая копируется при клонировании репозитория с другого компьютера.
			</p>
			<ul>У Git есть три основных состояния, в которых могут находиться ваши файлы: изменён (modified), индексирован
				(staged) и зафиксирован (committed):
				<li>К изменённым относятся файлы, которые поменялись, но ещё не были зафиксированы.</li>
				<li>Индексированный — это изменённый файл в его текущей версии, отмеченный для включения в следующий коммит.
				</li>
				<li>Зафиксированный значит, что файл уже сохранён в вашей локальной базе.</li>
			</ul>

			<h2 id="git-ignore">Для чего нужен файл .gitignore?</h2>
			<p>Зачастую, у вас имеется группа файлов, которые вы не только не хотите автоматически добавлять в репозиторий,
				но и видеть в списках неотслеживаемых. К таким файлам обычно относятся автоматически генерируемые файлы
				(различные логи, результаты сборки программ и т. п.). В таком случае, вы можете создать файл .gitignore. с
				перечислением шаблонов соответствующих таким файлам. Вот пример файла .gitignore:
			<pre><code>
				$ cat .gitignore
				*.[oa]
				*~
			</code></pre>
			</p>
			<p>Первая строка предписывает Git игнорировать любые файлы заканчивающиеся на «.o» или «.a» — объектные и
				архивные файлы, которые могут появиться во время сборки кода. Вторая строка предписывает игнорировать все
				файлы заканчивающиеся на тильду (~), которая используется во многих текстовых редакторах, например Emacs,
				для обозначения временных файлов. Вы можете также включить каталоги log, tmp или pid; автоматически
				создаваемую документацию; и т. д. и т. п. Хорошая практика заключается в настройке файла .gitignore до того,
				как начать серьёзно работать, это защитит вас от случайного добавления в репозиторий файлов, которых вы там
				видеть не хотите.</p>


			<h2 id="git-config">git config: что позволяет делать и какие три уровня конфигурации есть?</h2>
			<p>
			<ul>В состав Git входит утилита git config, которая позволяет просматривать и настраивать параметры,
				контролирующие все аспекты работы Git, а также его внешний вид. Эти параметры могут быть сохранены в трёх
				местах:
				<li>Файл [path]/etc/gitconfig содержит значения, общие для всех пользователей системы и для всех их
					репозиториев. Если при запуске git config указать параметр --system, то параметры будут читаться и
					сохраняться именно в этот файл. Так как этот файл является системным, то вам потребуются права
					суперпользователя для внесения изменений в него.</li>
				<li>Файл ~/.gitconfig или ~/.config/git/config хранит настройки конкретного пользователя. Этот файл
					используется при указании параметра --global и применяется ко всем репозиториям, с которыми вы работаете
					в текущей системе.</li>
				<li>Файл config в каталоге Git (т. е. .git/config) репозитория, который вы используете в данный момент,
					хранит настройки конкретного репозитория. Вы можете заставить Git читать и писать в этот файл с помощью
					параметра --local, но на самом деле это значение по умолчанию. Неудивительно, что вам нужно находиться
					где-то в репозитории Git, чтобы эта опция работала правильно.</li>
			</ul>
			Настройки на каждом следующем уровне подменяют настройки из предыдущих уровней, то есть значения в .git/config
			перекрывают соответствующие значения в [path]/etc/gitconfig.</p>
			<p>Чтобы посмотреть все установленные настройки и узнать где именно они заданы, используйте команду:
			<pre><code>$ git config --list --show-origin</code></pre>
			</p>

			<h2>Что делают, как и зачем использовать команды:</h2>
			<h3>add</h3>
			<p>Это многофункциональная команда, она используется для добавления под версионный контроль новых файлов, для
				индексации изменений, а также для других целей, например для указания файлов с исправленным конфликтом
				слияния. Вам может быть понятнее, если вы будете думать об этом как «добавить этот контент в следующий
				коммит», а не как «добавить этот файл в проект».</p>
			<h3>commit</h3>
			<p>Команда commit фиксирует проиндексированные изменения. Коммит сохраняет снимок состояния вашего индекса.
				Всё, что вы не проиндексировали, так и висит в рабочем каталоге как изменённое; вы можете сделать ещё один
				коммит, чтобы добавить эти изменения в репозиторий. Каждый раз, когда вы делаете коммит, вы сохраняете
				снимок состояния вашего проекта, который позже вы можете восстановить или с которым можно сравнить текущее
				состояние.</p>
			<h4>Как и при каких условиях можно сделать коммит, не написав перед этим явно git add?</h4>
			<p>Добавление параметра -a в команду git commit заставляет Git автоматически индексировать каждый уже
				отслеживаемый на момент коммита файл, позволяя вам обойтись без git add:</p>
			<h4>Как написать сообщение для коммита не открывая редактора?</h4>
			<p>набрать свой комментарий к коммиту в командной строке вместе с командой commit указав его после параметра
				-m:
				<code><pre>
						$ git commit -m "Story 182: fix benchmarks for speed"
					</pre></code>
			</p>
			<h4>Вы забыли добавить несколько файлов в индекс и сделали коммит, но ещё не отправили изменения в удалённый
				репозиторий. Как можно добавить забытые файлы в сделанный коммит? Можно ли так делать, если вы забыли
				добавить файлы в индекс, но уже отправили сделанный коммит в удалённый репозиторий?</h4>

			<h4>Как сделать коммит, отменяющий изменения, сделанные в одном из предыдущих коммитов, с помощью revert?</h4>

			<h2>Как посмотреть историю коммитов?</h2>
			<p>Командой git log</p>

	</main>

</body>

</html>